{"ast":null,"code":"import { isSVGTag } from '@vue/shared';\nimport MyEffect from \"@/views/Synth/Effects/MyFx\";\nimport { Gain, getDestination } from \"tone\";\nimport { nextTick } from \"vue\";\nconst types = ['none', 'reverb', 'delay', 'distortion', 'vibrato', 'pan', 'chorus'];\nconst Fx_colors = ['transparent', 'lightblue', 'deepskyblue', 'red', 'orange', 'darkorchid', 'yellow'];\nexport default {\n  props: [\"chainId\", \"id\", \"ref\"],\n  data() {\n    return {\n      modulation: 0,\n      is_down: false,\n      typeId: 0,\n      volume: 0,\n      //variables to solve\n      //dragging and clicking interference\n      startX: 0,\n      startY: 0,\n      endX: 0,\n      endY: 0,\n      threshold: 2 // adjust as needed\n    };\n  },\n\n  mounted() {\n    // gesture listeners\n    document.addEventListener(\"mouseup\", this.onMouseup);\n    document.addEventListener(\"mousemove\", this.onMousemove);\n    // init effect as bypass (a gain node)\n    this.effect = new MyEffect({\n      typeId: types[this.typeId],\n      modulation: this.modulation\n    });\n    // this.effect = this.fxHelper.generateToneFx('none');\n    // create the effect in the global fx matrix\n    this.fxChains[this.chainId][this.id] = this.effect;\n    // console.log(\"fx chain: \" + this.chainId + \" - fx id: \" + this.id)\n    // console.log(this.chainId, \" \", this.id)\n\n    // notify parent that each filter has been created\n    if (this.chainId === this.nFxChains - 1 && this.id === this.nFxXchain) {\n      this.$emit(\"fxMounted\");\n    }\n  },\n  computed: {\n    computedGlowStyle() {\n      return {\n        opacity: (this.modulation + 0.3) * 100 + \"%\",\n        background: Fx_colors[this.typeId]\n      };\n    },\n    iconDiv() {\n      let color = 'black';\n      if (this.chainId === 0) color = this.colors.purple.medium;\n      if (this.chainId === 1) color = this.colors.green.medium;\n      if (this.chainId === 2) color = this.colors.pink.medium;\n      return {\n        color: color\n      };\n    },\n    iconDivBlack() {\n      let color = 'black';\n      return {\n        color: color\n      };\n    },\n    onIconEnter() {\n      this.$refs['plus'].style.color = 'black';\n    },\n    onIconLeave() {\n      let color = 'black';\n      if (this.chainId === 0) color = this.colors.purple.medium;\n      if (this.chainId === 1) color = this.colors.green.medium;\n      if (this.chainId === 2) color = this.colors.pink.medium;\n      this.$refs['plus'].style.color = color;\n    }\n    /*     onIconLeave(){\n          let color = 'black'\n          if(this.chainId === 0 ) color = this.colors.purple.medium\n          if(this.chainId === 1 ) color = this.colors.green.medium\n          if(this.chainId === 2 ) color = this.colors.pink.medium\n          this.$refs['plus'].style.color = color\n        } */\n  },\n\n  components: {\n    isSVGTag\n  },\n  methods: {\n    // ------------------ USER INTERACTIONS -----------------------\n    nextFx() {\n      //calculate distance between mouseDown and mouseUp, if it is more than threshold pixels, then it is a drag\n      const distance = Math.sqrt(Math.pow(this.endX - this.startX, 2) + Math.pow(this.endY - this.startY, 2));\n      if (distance <= this.threshold) {\n        if (!this.is_down) {\n          // change fx type and index\n          this.typeId = this.generateNextTypeIndex();\n          let fxType = types[this.typeId];\n          //console.log(fxType)\n\n          this.changeFxType(fxType);\n        }\n      }\n    },\n    changeFxType(fxType) {\n      // disconnect old effect\n      this.effect.disconnect();\n      this.effect.dispose();\n\n      // create new effect\n      this.effect = new MyEffect({\n        type: fxType,\n        modulation: this.modulation\n      });\n      this.effect.setFxParams({\n        type: fxType,\n        mod: this.modulation\n      });\n\n      // attach new fx in the global fx matrix\n      // init effect\n      this.fxChains[this.chainId][this.id] = this.effect;\n      // connect effect\n      this.fxChains[this.chainId][this.id - 1].connect(this.fxChains[this.chainId][this.id].getToneReference());\n      if (this.fxChains[this.chainId][this.id + 1] instanceof MyEffect) {\n        this.fxChains[this.chainId][this.id].connect(this.fxChains[this.chainId][this.id + 1].getToneReference());\n      } else if (this.fxChains[this.chainId][this.id + 1] instanceof Gain) {\n        this.fxChains[this.chainId][this.id].connect(this.fxChains[this.chainId][this.id + 1]);\n      }\n      //console.log(this.fxChains)\n\n      /* // debug global fx matrix\n      this.fxChains.forEach((chain) => {\n        chain.forEach((fx) => {\n          if (fx instanceof MyEffect){\n            console.log(fx.getToneReference())\n          } else { console.log(fx) }\n        })\n      })*/\n    },\n\n    generateRandomTypeIndex() {\n      return Math.round(Math.random() * 10 + 1) % types.length;\n    },\n    generateNextTypeIndex() {\n      return (this.typeId + 1) % types.length;\n    },\n    setToBypass() {\n      this.typeId = 0;\n      this.changeFxType('none');\n\n      //console.log(\"set fx in position \" + this.chainId + \" - \" + this.id + \" to bypass\")\n    },\n\n    fxDown(e) {\n      //save mouseDown position\n      this.startX = e.clientX;\n      this.startY = e.clientY;\n      if (!this.is_down) this.is_down = true;\n    },\n    onMouseup(e) {\n      //save mouseUp position\n      this.endX = e.clientX;\n      this.endY = e.clientY;\n      if (this.is_down) this.is_down = false;\n    },\n    onMousemove(event) {\n      if (this.is_down) {\n        if (event.movementY < 0) {\n          this.modulation = Math.min(this.modulation - event.movementY / 100, 1);\n        } else {\n          this.modulation = Math.max(this.modulation - event.movementY / 100, 0);\n        }\n        this.effect.setFxParams({\n          fx: this.effect,\n          typeId: this.typeId,\n          mod: this.modulation\n        });\n\n        // console.log(this.modulation);\n      }\n    }\n  }\n};","map":{"version":3,"mappings":"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","names":["isSVGTag","MyEffect","Gain","getDestination","nextTick","types","Fx_colors","props","data","modulation","is_down","typeId","volume","startX","startY","endX","endY","threshold","mounted","document","addEventListener","onMouseup","onMousemove","effect","fxChains","chainId","id","nFxChains","nFxXchain","$emit","computed","computedGlowStyle","opacity","background","iconDiv","color","colors","purple","medium","green","pink","iconDivBlack","onIconEnter","$refs","style","onIconLeave","components","methods","nextFx","distance","Math","sqrt","pow","generateNextTypeIndex","fxType","changeFxType","disconnect","dispose","type","setFxParams","mod","connect","getToneReference","generateRandomTypeIndex","round","random","length","setToBypass","fxDown","e","clientX","clientY","event","movementY","min","max","fx"],"sourceRoot":"","sources":["/Users/guglielmofratticioli/Documents/POLIMI/FurioColombo.github.io/src/views/Synth/Effects/FxCell.vue"],"sourcesContent":["<template>\n  <div class=\"cell\" @click=\"nextFx\" @click.shift=\"setToBypass\" @mousedown=\"fxDown\">\n    <div class=\"icon\">\n      <div v-if=\"this.typeId === 0\" ref=\"plus\" :style=\"this.iconDiv\" @mouseover=\"this.onIconEnter\" @mouseout=\"onIconLeave\"> +</div>\n      <img v-if=\"this.typeId === 1\" src=\"@/icons/blizzard.svg\" alt=\"\">\n      <img v-if=\"this.typeId === 2\" src=\"@/icons/drop.svg\" alt=\"\">\n      <img v-if=\"this.typeId === 3\" src=\"@/icons/fire.svg\" alt=\"\">\n      <img v-if=\"this.typeId === 4\" src=\"@/icons/moon.svg\" alt=\"\">\n      <img v-if=\"this.typeId === 5\" src=\"@/icons/wind.svg\" alt=\"\">\n      <img v-if=\"this.typeId === 6\" src=\"@/icons/tornado.svg\" alt=\"\">\n    </div>\n    <div class=\"glow\" :style=\"computedGlowStyle\" @mousedown=\"fxDown\">\n    </div>\n  </div>\n</template>\n\n<script>\nimport { isSVGTag } from '@vue/shared';\nimport MyEffect from \"@/views/Synth/Effects/MyFx\";\nimport {Gain, getDestination} from \"tone\";\nimport { nextTick } from \"vue\";\n\nconst types = ['none', 'reverb', 'delay', 'distortion', 'vibrato', 'pan', 'chorus'];\nconst Fx_colors = ['transparent', 'lightblue', 'deepskyblue', 'red', 'orange', 'darkorchid', 'yellow'];\nexport default {\n  props: [\"chainId\", \"id\", \"ref\"],\n\n  data() {\n    return {\n      modulation: 0,\n      is_down: false,\n      typeId: 0,\n      volume: 0,\n\n      //variables to solve\n      //dragging and clicking interference\n      startX: 0,\n      startY: 0,\n      endX: 0,\n      endY: 0,\n      threshold: 2, // adjust as needed\n    };\n  },\n  mounted() {\n    // gesture listeners\n    document.addEventListener(\"mouseup\", this.onMouseup);\n    document.addEventListener(\"mousemove\", this.onMousemove);\n    // init effect as bypass (a gain node)\n    this.effect = new MyEffect({ typeId: types[this.typeId], modulation: this.modulation })\n    // this.effect = this.fxHelper.generateToneFx('none');\n    // create the effect in the global fx matrix\n    this.fxChains[this.chainId][this.id] = this.effect;\n    // console.log(\"fx chain: \" + this.chainId + \" - fx id: \" + this.id)\n    // console.log(this.chainId, \" \", this.id)\n\n    // notify parent that each filter has been created\n    if (this.chainId === this.nFxChains - 1 && this.id === this.nFxXchain) {\n      this.$emit(\"fxMounted\")\n    }\n  },\n\n  computed: {\n    computedGlowStyle() {\n      return {\n        opacity: (this.modulation + 0.3) * 100 + \"%\",\n        background: Fx_colors[this.typeId]\n      }\n    },\n    iconDiv() {\n      let color = 'black'\n      if (this.chainId === 0) color = this.colors.purple.medium\n      if (this.chainId === 1) color = this.colors.green.medium\n      if (this.chainId === 2) color = this.colors.pink.medium\n      return {\n        color: color,\n      }\n    },\n    iconDivBlack(){\n      let color = 'black'\n      return {\n        color: color,\n      }\n    },\n    onIconEnter() {\n      this.$refs['plus'].style.color = 'black'\n    },\n    onIconLeave() {\n      let color = 'black'\n      if (this.chainId === 0) color = this.colors.purple.medium\n      if (this.chainId === 1) color = this.colors.green.medium\n      if (this.chainId === 2) color = this.colors.pink.medium\n      this.$refs['plus'].style.color = color\n    }\n    /*     onIconLeave(){\n          let color = 'black'\n          if(this.chainId === 0 ) color = this.colors.purple.medium\n          if(this.chainId === 1 ) color = this.colors.green.medium\n          if(this.chainId === 2 ) color = this.colors.pink.medium\n          this.$refs['plus'].style.color = color\n        } */\n  },\n\n  components: { isSVGTag },\n\n  methods: {\n    // ------------------ USER INTERACTIONS -----------------------\n    nextFx() {\n      //calculate distance between mouseDown and mouseUp, if it is more than threshold pixels, then it is a drag\n      const distance = Math.sqrt(\n        Math.pow(this.endX - this.startX, 2) +\n        Math.pow(this.endY - this.startY, 2)\n      );\n\n      if (distance <= this.threshold) {\n        if (!this.is_down) {\n          // change fx type and index\n          this.typeId = this.generateNextTypeIndex();\n          let fxType = types[this.typeId]\n          //console.log(fxType)\n\n          this.changeFxType(fxType)\n        }\n      }\n\n    },\n\n    changeFxType(fxType) {\n      // disconnect old effect\n      this.effect.disconnect();\n      this.effect.dispose();\n\n      // create new effect\n      this.effect = new MyEffect({ type: fxType, modulation: this.modulation })\n      this.effect.setFxParams({ type: fxType, mod: this.modulation })\n\n      // attach new fx in the global fx matrix\n      // init effect\n      this.fxChains[this.chainId][this.id] = this.effect;\n      // connect effect\n      this.fxChains[this.chainId][this.id-1].connect(this.fxChains[this.chainId][this.id].getToneReference());\n      if(this.fxChains[this.chainId][this.id+1] instanceof MyEffect) {\n        this.fxChains[this.chainId][this.id].connect(this.fxChains[this.chainId][this.id + 1].getToneReference())\n      } else if(this.fxChains[this.chainId][this.id+1] instanceof Gain){\n        this.fxChains[this.chainId][this.id].connect(this.fxChains[this.chainId][this.id + 1])\n      }\n      //console.log(this.fxChains)\n\n      /* // debug global fx matrix\n      this.fxChains.forEach((chain) => {\n        chain.forEach((fx) => {\n          if (fx instanceof MyEffect){\n            console.log(fx.getToneReference())\n          } else { console.log(fx) }\n        })\n      })*/\n    },\n\n    generateRandomTypeIndex() {\n      return Math.round(Math.random() * 10 + 1) % types.length\n    },\n\n    generateNextTypeIndex() {\n      return (this.typeId + 1) % types.length;\n    },\n\n    setToBypass() {\n      this.typeId = 0;\n      this.changeFxType('none')\n\n      //console.log(\"set fx in position \" + this.chainId + \" - \" + this.id + \" to bypass\")\n    },\n\n    fxDown(e) {\n      //save mouseDown position\n      this.startX = e.clientX;\n      this.startY = e.clientY;\n\n      if (!this.is_down)\n        this.is_down = true;\n    },\n    onMouseup(e) {\n      //save mouseUp position\n      this.endX = e.clientX;\n      this.endY = e.clientY;\n      if (this.is_down)\n        this.is_down = false;\n    },\n    onMousemove(event) {\n      if (this.is_down) {\n        if (event.movementY < 0) {\n          this.modulation = Math.min(this.modulation - event.movementY / 100, 1);\n        } else {\n          this.modulation = Math.max(this.modulation - event.movementY / 100, 0);\n        }\n        this.effect.setFxParams({ fx: this.effect, typeId: this.typeId, mod: this.modulation })\n\n        // console.log(this.modulation);\n      }\n    }\n  },\n}\n</script>\n\n<style scoped>\n.cell {\n  position: relative;\n  height: 85%;\n  background-color: transparent;\n  display: flex;\n  margin: 10%;\n  align-items: center;\n  justify-content: center;\n}\n\n.icon {\n  display: flex;\n  aspect-ratio: 1/1;\n  position: absolute;\n  z-index: 2;\n  background-color: transparent;\n}\n\n.icon div {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  font-size: 1.5vw;\n  height: 100%;\n  aspect-ratio: 1/1;\n  background-color: transparent;\n}\n\n.icon img {\n  width: 1.5vw;\n  aspect-ratio: 1/1;\n  opacity: 80%;\n  -webkit-user-drag: none;\n}\n\n.glow {\n  border-radius: 5%;\n  flex: 1;\n  height: 100%;\n  width: 100%;\n  position: absolute;\n  z-index: 1;\n  background-color: red;\n}\n\n.glow div {\n  height: 100%;\n  width: 100%;\n  opacity: 100%;\n  color: black;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  font-size: 2vw;\n}\n</style>"]},"metadata":{},"sourceType":"module","externalDependencies":[]}