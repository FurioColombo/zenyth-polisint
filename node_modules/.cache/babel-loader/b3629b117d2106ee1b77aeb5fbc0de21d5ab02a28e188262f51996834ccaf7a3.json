{"ast":null,"code":"import \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.typed-array.float32-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.find-last.js\";\nimport \"core-js/modules/es.typed-array.find-last-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/es.array.slice.js\";\nexport function copyFromChannel(audioBuffer,\n// @todo There is currently no way to define something like { [ key: number | string ]: Float32Array }\nparent, key, channelNumber, bufferOffset) {\n  if (typeof audioBuffer.copyFromChannel === 'function') {\n    // The byteLength will be 0 when the ArrayBuffer was transferred.\n    if (parent[key].byteLength === 0) {\n      parent[key] = new Float32Array(128);\n    }\n    audioBuffer.copyFromChannel(parent[key], channelNumber, bufferOffset);\n    // Bug #5: Safari does not support copyFromChannel().\n  } else {\n    var channelData = audioBuffer.getChannelData(channelNumber);\n    // The byteLength will be 0 when the ArrayBuffer was transferred.\n    if (parent[key].byteLength === 0) {\n      parent[key] = channelData.slice(bufferOffset, bufferOffset + 128);\n    } else {\n      var slicedInput = new Float32Array(channelData.buffer, bufferOffset * Float32Array.BYTES_PER_ELEMENT, 128);\n      parent[key].set(slicedInput);\n    }\n  }\n}","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgBA,OAAM,SAAUA,eAAe,CAC3BC,WAA+B;AAC/B;AACAC,MAAW,EACXC,GAAoB,EACpBC,aAAqB,EACrBC,YAAoB;EAEpB,IAAI,OAAOJ,WAAW,CAACD,eAAe,KAAK,UAAU,EAAE;IACnD;IACA,IAAIE,MAAM,CAACC,GAAG,CAAC,CAACG,UAAU,KAAK,CAAC,EAAE;MAC9BJ,MAAM,CAACC,GAAG,CAAC,GAAG,IAAII,YAAY,CAAC,GAAG,CAAC;;IAGvCN,WAAW,CAACD,eAAe,CAACE,MAAM,CAACC,GAAG,CAAC,EAAEC,aAAa,EAAEC,YAAY,CAAC;IAErE;GACH,MAAM;IACH,IAAMG,WAAW,GAAGP,WAAW,CAACQ,cAAc,CAACL,aAAa,CAAC;IAE7D;IACA,IAAIF,MAAM,CAACC,GAAG,CAAC,CAACG,UAAU,KAAK,CAAC,EAAE;MAC9BJ,MAAM,CAACC,GAAG,CAAC,GAAGK,WAAW,CAACE,KAAK,CAACL,YAAY,EAAEA,YAAY,GAAG,GAAG,CAAC;KACpE,MAAM;MACH,IAAMM,WAAW,GAAG,IAAIJ,YAAY,CAACC,WAAW,CAACI,MAAM,EAAEP,YAAY,GAAGE,YAAY,CAACM,iBAAiB,EAAE,GAAG,CAAC;MAE5GX,MAAM,CAACC,GAAG,CAAC,CAACW,GAAG,CAACH,WAAW,CAAC;;;AAGxC","names":["copyFromChannel","audioBuffer","parent","key","channelNumber","bufferOffset","byteLength","Float32Array","channelData","getChannelData","slice","slicedInput","buffer","BYTES_PER_ELEMENT","set"],"sourceRoot":"","sources":["../../../src/helpers/copy-from-channel.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module","externalDependencies":[]}