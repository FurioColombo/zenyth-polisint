{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/eliapirrello/Documents/GitHub/zenyth/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _regeneratorRuntime from \"/Users/eliapirrello/Documents/GitHub/zenyth/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _classCallCheck from \"/Users/eliapirrello/Documents/GitHub/zenyth/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/eliapirrello/Documents/GitHub/zenyth/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"/Users/eliapirrello/Documents/GitHub/zenyth/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/eliapirrello/Documents/GitHub/zenyth/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/eliapirrello/Documents/GitHub/zenyth/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/eliapirrello/Documents/GitHub/zenyth/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.array.reverse.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.typed-array.float32-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.find-last.js\";\nimport \"core-js/modules/es.typed-array.find-last-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.match.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport \"core-js/modules/es.string.ends-with.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport { __awaiter } from \"tslib\";\nimport { getContext } from \"../Global\";\nimport { Tone } from \"../Tone\";\nimport { isAudioBuffer } from \"../util/AdvancedTypeCheck\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { noOp } from \"../util/Interface\";\nimport { isArray, isNumber, isString } from \"../util/TypeCheck\";\nimport { assert } from \"../util/Debug\";\n/**\n * AudioBuffer loading and storage. ToneAudioBuffer is used internally by all\n * classes that make requests for audio files such as Tone.Player,\n * Tone.Sampler and Tone.Convolver.\n * @example\n * const buffer = new Tone.ToneAudioBuffer(\"https://tonejs.github.io/audio/casio/A1.mp3\", () => {\n * \tconsole.log(\"loaded\");\n * });\n * @category Core\n */\nexport var ToneAudioBuffer = /*#__PURE__*/function (_Tone) {\n  _inherits(ToneAudioBuffer, _Tone);\n  var _super = _createSuper(ToneAudioBuffer);\n  function ToneAudioBuffer() {\n    var _this;\n    _classCallCheck(this, ToneAudioBuffer);\n    _this = _super.call(this);\n    _this.name = \"ToneAudioBuffer\";\n    /**\n     * Callback when the buffer is loaded.\n     */\n    _this.onload = noOp;\n    var options = optionsFromArguments(ToneAudioBuffer.getDefaults(), arguments, [\"url\", \"onload\", \"onerror\"]);\n    _this.reverse = options.reverse;\n    _this.onload = options.onload;\n    if (options.url && isAudioBuffer(options.url) || options.url instanceof ToneAudioBuffer) {\n      _this.set(options.url);\n    } else if (isString(options.url)) {\n      // initiate the download\n      _this.load(options.url)[\"catch\"](options.onerror);\n    }\n    return _this;\n  }\n  _createClass(ToneAudioBuffer, [{\n    key: \"sampleRate\",\n    get:\n    /**\n     * The sample rate of the AudioBuffer\n     */\n    function get() {\n      if (this._buffer) {\n        return this._buffer.sampleRate;\n      } else {\n        return getContext().sampleRate;\n      }\n    }\n    /**\n     * Pass in an AudioBuffer or ToneAudioBuffer to set the value of this buffer.\n     */\n  }, {\n    key: \"set\",\n    value: function set(buffer) {\n      var _this2 = this;\n      if (buffer instanceof ToneAudioBuffer) {\n        // if it's loaded, set it\n        if (buffer.loaded) {\n          this._buffer = buffer.get();\n        } else {\n          // otherwise when it's loaded, invoke it's callback\n          buffer.onload = function () {\n            _this2.set(buffer);\n            _this2.onload(_this2);\n          };\n        }\n      } else {\n        this._buffer = buffer;\n      }\n      // reverse it initially\n      if (this._reversed) {\n        this._reverse();\n      }\n      return this;\n    }\n    /**\n     * The audio buffer stored in the object.\n     */\n  }, {\n    key: \"get\",\n    value: function get() {\n      return this._buffer;\n    }\n    /**\n     * Makes an fetch request for the selected url then decodes the file as an audio buffer.\n     * Invokes the callback once the audio buffer loads.\n     * @param url The url of the buffer to load. filetype support depends on the browser.\n     * @returns A Promise which resolves with this ToneAudioBuffer\n     */\n  }, {\n    key: \"load\",\n    value: function load(url) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var _this3 = this;\n        var doneLoading, index;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              doneLoading = ToneAudioBuffer.load(url).then(function (audioBuffer) {\n                _this3.set(audioBuffer);\n                // invoke the onload method\n                _this3.onload(_this3);\n              });\n              ToneAudioBuffer.downloads.push(doneLoading);\n              _context.prev = 2;\n              _context.next = 5;\n              return doneLoading;\n            case 5:\n              _context.prev = 5;\n              // remove the downloaded file\n              index = ToneAudioBuffer.downloads.indexOf(doneLoading);\n              ToneAudioBuffer.downloads.splice(index, 1);\n              return _context.finish(5);\n            case 9:\n              return _context.abrupt(\"return\", this);\n            case 10:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this, [[2,, 5, 9]]);\n      }));\n    }\n    /**\n     * clean up\n     */\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(ToneAudioBuffer.prototype), \"dispose\", this).call(this);\n      this._buffer = undefined;\n      return this;\n    }\n    /**\n     * Set the audio buffer from the array.\n     * To create a multichannel AudioBuffer, pass in a multidimensional array.\n     * @param array The array to fill the audio buffer\n     */\n  }, {\n    key: \"fromArray\",\n    value: function fromArray(array) {\n      var isMultidimensional = isArray(array) && array[0].length > 0;\n      var channels = isMultidimensional ? array.length : 1;\n      var len = isMultidimensional ? array[0].length : array.length;\n      var context = getContext();\n      var buffer = context.createBuffer(channels, len, context.sampleRate);\n      var multiChannelArray = !isMultidimensional && channels === 1 ? [array] : array;\n      for (var c = 0; c < channels; c++) {\n        buffer.copyToChannel(multiChannelArray[c], c);\n      }\n      this._buffer = buffer;\n      return this;\n    }\n    /**\n     * Sums multiple channels into 1 channel\n     * @param chanNum Optionally only copy a single channel from the array.\n     */\n  }, {\n    key: \"toMono\",\n    value: function toMono(chanNum) {\n      if (isNumber(chanNum)) {\n        this.fromArray(this.toArray(chanNum));\n      } else {\n        var outputArray = new Float32Array(this.length);\n        var numChannels = this.numberOfChannels;\n        for (var channel = 0; channel < numChannels; channel++) {\n          var channelArray = this.toArray(channel);\n          for (var i = 0; i < channelArray.length; i++) {\n            outputArray[i] += channelArray[i];\n          }\n        }\n        // divide by the number of channels\n        outputArray = outputArray.map(function (sample) {\n          return sample / numChannels;\n        });\n        this.fromArray(outputArray);\n      }\n      return this;\n    }\n    /**\n     * Get the buffer as an array. Single channel buffers will return a 1-dimensional\n     * Float32Array, and multichannel buffers will return multidimensional arrays.\n     * @param channel Optionally only copy a single channel from the array.\n     */\n  }, {\n    key: \"toArray\",\n    value: function toArray(channel) {\n      if (isNumber(channel)) {\n        return this.getChannelData(channel);\n      } else if (this.numberOfChannels === 1) {\n        return this.toArray(0);\n      } else {\n        var ret = [];\n        for (var c = 0; c < this.numberOfChannels; c++) {\n          ret[c] = this.getChannelData(c);\n        }\n        return ret;\n      }\n    }\n    /**\n     * Returns the Float32Array representing the PCM audio data for the specific channel.\n     * @param  channel  The channel number to return\n     * @return The audio as a TypedArray\n     */\n  }, {\n    key: \"getChannelData\",\n    value: function getChannelData(channel) {\n      if (this._buffer) {\n        return this._buffer.getChannelData(channel);\n      } else {\n        return new Float32Array(0);\n      }\n    }\n    /**\n     * Cut a subsection of the array and return a buffer of the\n     * subsection. Does not modify the original buffer\n     * @param start The time to start the slice\n     * @param end The end time to slice. If none is given will default to the end of the buffer\n     */\n  }, {\n    key: \"slice\",\n    value: function slice(start) {\n      var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.duration;\n      var startSamples = Math.floor(start * this.sampleRate);\n      var endSamples = Math.floor(end * this.sampleRate);\n      assert(startSamples < endSamples, \"The start time must be less than the end time\");\n      var length = endSamples - startSamples;\n      var retBuffer = getContext().createBuffer(this.numberOfChannels, length, this.sampleRate);\n      for (var channel = 0; channel < this.numberOfChannels; channel++) {\n        retBuffer.copyToChannel(this.getChannelData(channel).subarray(startSamples, endSamples), channel);\n      }\n      return new ToneAudioBuffer(retBuffer);\n    }\n    /**\n     * Reverse the buffer.\n     */\n  }, {\n    key: \"_reverse\",\n    value: function _reverse() {\n      if (this.loaded) {\n        for (var i = 0; i < this.numberOfChannels; i++) {\n          this.getChannelData(i).reverse();\n        }\n      }\n      return this;\n    }\n    /**\n     * If the buffer is loaded or not\n     */\n  }, {\n    key: \"loaded\",\n    get: function get() {\n      return this.length > 0;\n    }\n    /**\n     * The duration of the buffer in seconds.\n     */\n  }, {\n    key: \"duration\",\n    get: function get() {\n      if (this._buffer) {\n        return this._buffer.duration;\n      } else {\n        return 0;\n      }\n    }\n    /**\n     * The length of the buffer in samples\n     */\n  }, {\n    key: \"length\",\n    get: function get() {\n      if (this._buffer) {\n        return this._buffer.length;\n      } else {\n        return 0;\n      }\n    }\n    /**\n     * The number of discrete audio channels. Returns 0 if no buffer is loaded.\n     */\n  }, {\n    key: \"numberOfChannels\",\n    get: function get() {\n      if (this._buffer) {\n        return this._buffer.numberOfChannels;\n      } else {\n        return 0;\n      }\n    }\n    /**\n     * Reverse the buffer.\n     */\n  }, {\n    key: \"reverse\",\n    get: function get() {\n      return this._reversed;\n    },\n    set: function set(rev) {\n      if (this._reversed !== rev) {\n        this._reversed = rev;\n        this._reverse();\n      }\n    }\n    /**\n     * Create a ToneAudioBuffer from the array. To create a multichannel AudioBuffer,\n     * pass in a multidimensional array.\n     * @param array The array to fill the audio buffer\n     * @return A ToneAudioBuffer created from the array\n     */\n  }], [{\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return {\n        onerror: noOp,\n        onload: noOp,\n        reverse: false\n      };\n    }\n  }, {\n    key: \"fromArray\",\n    value: function fromArray(array) {\n      return new ToneAudioBuffer().fromArray(array);\n    }\n    /**\n     * Creates a ToneAudioBuffer from a URL, returns a promise which resolves to a ToneAudioBuffer\n     * @param  url The url to load.\n     * @return A promise which resolves to a ToneAudioBuffer\n     */\n  }, {\n    key: \"fromUrl\",\n    value: function fromUrl(url) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var buffer;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              buffer = new ToneAudioBuffer();\n              _context2.next = 3;\n              return buffer.load(url);\n            case 3:\n              return _context2.abrupt(\"return\", _context2.sent);\n            case 4:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2);\n      }));\n    }\n    /**\n     * Loads a url using fetch and returns the AudioBuffer.\n     */\n  }, {\n    key: \"load\",\n    value: function load(url) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var matches, extensions, extension, _iterator, _step, ext, baseUrl, response, arrayBuffer, audioBuffer;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              // test if the url contains multiple extensions\n              matches = url.match(/\\[([^\\]\\[]+\\|.+)\\]$/);\n              if (!matches) {\n                _context3.next = 23;\n                break;\n              }\n              extensions = matches[1].split(\"|\");\n              extension = extensions[0];\n              _iterator = _createForOfIteratorHelper(extensions);\n              _context3.prev = 5;\n              _iterator.s();\n            case 7:\n              if ((_step = _iterator.n()).done) {\n                _context3.next = 14;\n                break;\n              }\n              ext = _step.value;\n              if (!ToneAudioBuffer.supportsType(ext)) {\n                _context3.next = 12;\n                break;\n              }\n              extension = ext;\n              return _context3.abrupt(\"break\", 14);\n            case 12:\n              _context3.next = 7;\n              break;\n            case 14:\n              _context3.next = 19;\n              break;\n            case 16:\n              _context3.prev = 16;\n              _context3.t0 = _context3[\"catch\"](5);\n              _iterator.e(_context3.t0);\n            case 19:\n              _context3.prev = 19;\n              _iterator.f();\n              return _context3.finish(19);\n            case 22:\n              url = url.replace(matches[0], extension);\n            case 23:\n              // make sure there is a slash between the baseUrl and the url\n              baseUrl = ToneAudioBuffer.baseUrl === \"\" || ToneAudioBuffer.baseUrl.endsWith(\"/\") ? ToneAudioBuffer.baseUrl : ToneAudioBuffer.baseUrl + \"/\";\n              _context3.next = 26;\n              return fetch(baseUrl + url);\n            case 26:\n              response = _context3.sent;\n              if (response.ok) {\n                _context3.next = 29;\n                break;\n              }\n              throw new Error(\"could not load url: \".concat(url));\n            case 29:\n              _context3.next = 31;\n              return response.arrayBuffer();\n            case 31:\n              arrayBuffer = _context3.sent;\n              _context3.next = 34;\n              return getContext().decodeAudioData(arrayBuffer);\n            case 34:\n              audioBuffer = _context3.sent;\n              return _context3.abrupt(\"return\", audioBuffer);\n            case 36:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, null, [[5, 16, 19, 22]]);\n      }));\n    }\n    /**\n     * Checks a url's extension to see if the current browser can play that file type.\n     * @param url The url/extension to test\n     * @return If the file extension can be played\n     * @static\n     * @example\n     * Tone.ToneAudioBuffer.supportsType(\"wav\"); // returns true\n     * Tone.ToneAudioBuffer.supportsType(\"path/to/file.wav\"); // returns true\n     */\n  }, {\n    key: \"supportsType\",\n    value: function supportsType(url) {\n      var extensions = url.split(\".\");\n      var extension = extensions[extensions.length - 1];\n      var response = document.createElement(\"audio\").canPlayType(\"audio/\" + extension);\n      return response !== \"\";\n    }\n    /**\n     * Returns a Promise which resolves when all of the buffers have loaded\n     */\n  }, {\n    key: \"loaded\",\n    value: function loaded() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              _context4.next = 2;\n              return Promise.resolve();\n            case 2:\n              if (!ToneAudioBuffer.downloads.length) {\n                _context4.next = 7;\n                break;\n              }\n              _context4.next = 5;\n              return ToneAudioBuffer.downloads[0];\n            case 5:\n              _context4.next = 2;\n              break;\n            case 7:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4);\n      }));\n    }\n  }]);\n  return ToneAudioBuffer;\n}(Tone);\n//-------------------------------------\n// STATIC METHODS\n//-------------------------------------\n/**\n * A path which is prefixed before every url.\n */\nToneAudioBuffer.baseUrl = \"\";\n/**\n * All of the downloads\n */\nToneAudioBuffer.downloads = [];","map":{"version":3,"mappings":"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","names":["getContext","Tone","isAudioBuffer","optionsFromArguments","noOp","isArray","isNumber","isString","assert","ToneAudioBuffer","options","getDefaults","arguments","reverse","onload","url","set","load","onerror","_buffer","sampleRate","buffer","loaded","get","_reversed","_reverse","doneLoading","then","audioBuffer","downloads","push","index","indexOf","splice","undefined","array","isMultidimensional","length","channels","len","context","createBuffer","multiChannelArray","c","copyToChannel","chanNum","fromArray","toArray","outputArray","Float32Array","numChannels","numberOfChannels","channel","channelArray","i","map","sample","getChannelData","ret","start","end","duration","startSamples","Math","floor","endSamples","retBuffer","subarray","rev","matches","match","extensions","split","extension","ext","supportsType","replace","baseUrl","endsWith","fetch","response","ok","Error","arrayBuffer","decodeAudioData","document","createElement","canPlayType","Promise","resolve"],"sourceRoot":"","sources":["../../../../Tone/core/context/ToneAudioBuffer.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module","externalDependencies":[]}