{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { connect } from \"../../core/context/ToneAudioNode\";\nimport { Param } from \"../../core/context/Param\";\nimport { ToneAudioBuffer } from \"../../core/context/ToneAudioBuffer\";\nimport { defaultArg, optionsFromArguments } from \"../../core/util/Defaults\";\nimport { noOp } from \"../../core/util/Interface\";\nimport { isDefined } from \"../../core/util/TypeCheck\";\nimport { assert } from \"../../core/util/Debug\";\nimport { OneShotSource } from \"../OneShotSource\";\nimport { EQ, GTE, LT } from \"../../core/util/Math\";\n/**\n * Wrapper around the native BufferSourceNode.\n * @category Source\n */\nexport class ToneBufferSource extends OneShotSource {\n  constructor() {\n    super(optionsFromArguments(ToneBufferSource.getDefaults(), arguments, [\"url\", \"onload\"]));\n    this.name = \"ToneBufferSource\";\n    /**\n     * The oscillator\n     */\n    this._source = this.context.createBufferSource();\n    this._internalChannels = [this._source];\n    /**\n     * indicators if the source has started/stopped\n     */\n    this._sourceStarted = false;\n    this._sourceStopped = false;\n    const options = optionsFromArguments(ToneBufferSource.getDefaults(), arguments, [\"url\", \"onload\"]);\n    connect(this._source, this._gainNode);\n    this._source.onended = () => this._stopSource();\n    /**\n     * The playbackRate of the buffer\n     */\n    this.playbackRate = new Param({\n      context: this.context,\n      param: this._source.playbackRate,\n      units: \"positive\",\n      value: options.playbackRate\n    });\n    // set some values initially\n    this.loop = options.loop;\n    this.loopStart = options.loopStart;\n    this.loopEnd = options.loopEnd;\n    this._buffer = new ToneAudioBuffer(options.url, options.onload, options.onerror);\n    this._internalChannels.push(this._source);\n  }\n  static getDefaults() {\n    return Object.assign(OneShotSource.getDefaults(), {\n      url: new ToneAudioBuffer(),\n      loop: false,\n      loopEnd: 0,\n      loopStart: 0,\n      onload: noOp,\n      onerror: noOp,\n      playbackRate: 1\n    });\n  }\n  /**\n   * The fadeIn time of the amplitude envelope.\n   */\n  get fadeIn() {\n    return this._fadeIn;\n  }\n  set fadeIn(t) {\n    this._fadeIn = t;\n  }\n  /**\n   * The fadeOut time of the amplitude envelope.\n   */\n  get fadeOut() {\n    return this._fadeOut;\n  }\n  set fadeOut(t) {\n    this._fadeOut = t;\n  }\n  /**\n   * The curve applied to the fades, either \"linear\" or \"exponential\"\n   */\n  get curve() {\n    return this._curve;\n  }\n  set curve(t) {\n    this._curve = t;\n  }\n  /**\n   * Start the buffer\n   * @param  time When the player should start.\n   * @param  offset The offset from the beginning of the sample to start at.\n   * @param  duration How long the sample should play. If no duration is given, it will default to the full length of the sample (minus any offset)\n   * @param  gain  The gain to play the buffer back at.\n   */\n  start(time, offset, duration, gain = 1) {\n    assert(this.buffer.loaded, \"buffer is either not set or not loaded\");\n    const computedTime = this.toSeconds(time);\n    // apply the gain envelope\n    this._startGain(computedTime, gain);\n    // if it's a loop the default offset is the loopstart point\n    if (this.loop) {\n      offset = defaultArg(offset, this.loopStart);\n    } else {\n      // otherwise the default offset is 0\n      offset = defaultArg(offset, 0);\n    }\n    // make sure the offset is not less than 0\n    let computedOffset = Math.max(this.toSeconds(offset), 0);\n    // start the buffer source\n    if (this.loop) {\n      // modify the offset if it's greater than the loop time\n      const loopEnd = this.toSeconds(this.loopEnd) || this.buffer.duration;\n      const loopStart = this.toSeconds(this.loopStart);\n      const loopDuration = loopEnd - loopStart;\n      // move the offset back\n      if (GTE(computedOffset, loopEnd)) {\n        computedOffset = (computedOffset - loopStart) % loopDuration + loopStart;\n      }\n      // when the offset is very close to the duration, set it to 0\n      if (EQ(computedOffset, this.buffer.duration)) {\n        computedOffset = 0;\n      }\n    }\n    // this.buffer.loaded would have return false if the AudioBuffer was undefined\n    this._source.buffer = this.buffer.get();\n    this._source.loopEnd = this.toSeconds(this.loopEnd) || this.buffer.duration;\n    if (LT(computedOffset, this.buffer.duration)) {\n      this._sourceStarted = true;\n      this._source.start(computedTime, computedOffset);\n    }\n    // if a duration is given, schedule a stop\n    if (isDefined(duration)) {\n      let computedDur = this.toSeconds(duration);\n      // make sure it's never negative\n      computedDur = Math.max(computedDur, 0);\n      this.stop(computedTime + computedDur);\n    }\n    return this;\n  }\n  _stopSource(time) {\n    if (!this._sourceStopped && this._sourceStarted) {\n      this._sourceStopped = true;\n      this._source.stop(this.toSeconds(time));\n      this._onended();\n    }\n  }\n  /**\n   * If loop is true, the loop will start at this position.\n   */\n  get loopStart() {\n    return this._source.loopStart;\n  }\n  set loopStart(loopStart) {\n    this._source.loopStart = this.toSeconds(loopStart);\n  }\n  /**\n   * If loop is true, the loop will end at this position.\n   */\n  get loopEnd() {\n    return this._source.loopEnd;\n  }\n  set loopEnd(loopEnd) {\n    this._source.loopEnd = this.toSeconds(loopEnd);\n  }\n  /**\n   * The audio buffer belonging to the player.\n   */\n  get buffer() {\n    return this._buffer;\n  }\n  set buffer(buffer) {\n    this._buffer.set(buffer);\n  }\n  /**\n   * If the buffer should loop once it's over.\n   */\n  get loop() {\n    return this._source.loop;\n  }\n  set loop(loop) {\n    this._source.loop = loop;\n    if (this._sourceStarted) {\n      this.cancelStop();\n    }\n  }\n  /**\n   * Clean up.\n   */\n  dispose() {\n    super.dispose();\n    this._source.onended = null;\n    this._source.disconnect();\n    this._buffer.dispose();\n    this.playbackRate.dispose();\n    return this;\n  }\n}","map":{"version":3,"mappings":"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","names":["connect","Param","ToneAudioBuffer","defaultArg","optionsFromArguments","noOp","isDefined","assert","OneShotSource","EQ","GTE","LT","ToneBufferSource","constructor","getDefaults","arguments","context","createBufferSource","_source","options","_gainNode","onended","_stopSource","playbackRate","param","units","value","loop","loopStart","loopEnd","_buffer","url","onload","onerror","_internalChannels","push","Object","assign","fadeIn","_fadeIn","t","fadeOut","_fadeOut","curve","_curve","start","time","offset","duration","gain","buffer","loaded","computedTime","toSeconds","_startGain","computedOffset","Math","max","loopDuration","get","_sourceStarted","computedDur","stop","_sourceStopped","_onended","set","cancelStop","dispose","disconnect"],"sourceRoot":"","sources":["../../../../Tone/source/buffer/ToneBufferSource.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module","externalDependencies":[]}