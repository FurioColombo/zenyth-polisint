{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { __awaiter } from \"tslib\";\nimport { Ticker } from \"../clock/Ticker\";\nimport { isAudioContext } from \"../util/AdvancedTypeCheck\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isDefined, isString } from \"../util/TypeCheck\";\nimport { createAudioContext, createAudioWorkletNode } from \"./AudioContext\";\nimport { closeContext, initializeContext } from \"./ContextInitialization\";\nimport { BaseContext } from \"./BaseContext\";\nimport { assert } from \"../util/Debug\";\n/**\n * Wrapper around the native AudioContext.\n * @category Core\n */\nexport class Context extends BaseContext {\n  constructor() {\n    super();\n    this.name = \"Context\";\n    /**\n     * An object containing all of the constants AudioBufferSourceNodes\n     */\n    this._constants = new Map();\n    /**\n     * All of the setTimeout events.\n     */\n    this._timeouts = new Timeline();\n    /**\n     * The timeout id counter\n     */\n    this._timeoutIds = 0;\n    /**\n     * Private indicator if the context has been initialized\n     */\n    this._initialized = false;\n    /**\n     * Indicates if the context is an OfflineAudioContext or an AudioContext\n     */\n    this.isOffline = false;\n    //--------------------------------------------\n    // AUDIO WORKLET\n    //--------------------------------------------\n    /**\n     * Maps a module name to promise of the addModule method\n     */\n    this._workletModules = new Map();\n    const options = optionsFromArguments(Context.getDefaults(), arguments, [\"context\"]);\n    if (options.context) {\n      this._context = options.context;\n    } else {\n      this._context = createAudioContext({\n        latencyHint: options.latencyHint\n      });\n    }\n    this._ticker = new Ticker(this.emit.bind(this, \"tick\"), options.clockSource, options.updateInterval);\n    this.on(\"tick\", this._timeoutLoop.bind(this));\n    // fwd events from the context\n    this._context.onstatechange = () => {\n      this.emit(\"statechange\", this.state);\n    };\n    this._setLatencyHint(options.latencyHint);\n    this.lookAhead = options.lookAhead;\n  }\n  static getDefaults() {\n    return {\n      clockSource: \"worker\",\n      latencyHint: \"interactive\",\n      lookAhead: 0.1,\n      updateInterval: 0.05\n    };\n  }\n  /**\n   * Finish setting up the context. **You usually do not need to do this manually.**\n   */\n  initialize() {\n    if (!this._initialized) {\n      // add any additional modules\n      initializeContext(this);\n      this._initialized = true;\n    }\n    return this;\n  }\n  //---------------------------\n  // BASE AUDIO CONTEXT METHODS\n  //---------------------------\n  createAnalyser() {\n    return this._context.createAnalyser();\n  }\n  createOscillator() {\n    return this._context.createOscillator();\n  }\n  createBufferSource() {\n    return this._context.createBufferSource();\n  }\n  createBiquadFilter() {\n    return this._context.createBiquadFilter();\n  }\n  createBuffer(numberOfChannels, length, sampleRate) {\n    return this._context.createBuffer(numberOfChannels, length, sampleRate);\n  }\n  createChannelMerger(numberOfInputs) {\n    return this._context.createChannelMerger(numberOfInputs);\n  }\n  createChannelSplitter(numberOfOutputs) {\n    return this._context.createChannelSplitter(numberOfOutputs);\n  }\n  createConstantSource() {\n    return this._context.createConstantSource();\n  }\n  createConvolver() {\n    return this._context.createConvolver();\n  }\n  createDelay(maxDelayTime) {\n    return this._context.createDelay(maxDelayTime);\n  }\n  createDynamicsCompressor() {\n    return this._context.createDynamicsCompressor();\n  }\n  createGain() {\n    return this._context.createGain();\n  }\n  createIIRFilter(feedForward, feedback) {\n    // @ts-ignore\n    return this._context.createIIRFilter(feedForward, feedback);\n  }\n  createPanner() {\n    return this._context.createPanner();\n  }\n  createPeriodicWave(real, imag, constraints) {\n    return this._context.createPeriodicWave(real, imag, constraints);\n  }\n  createStereoPanner() {\n    return this._context.createStereoPanner();\n  }\n  createWaveShaper() {\n    return this._context.createWaveShaper();\n  }\n  createMediaStreamSource(stream) {\n    assert(isAudioContext(this._context), \"Not available if OfflineAudioContext\");\n    const context = this._context;\n    return context.createMediaStreamSource(stream);\n  }\n  createMediaElementSource(element) {\n    assert(isAudioContext(this._context), \"Not available if OfflineAudioContext\");\n    const context = this._context;\n    return context.createMediaElementSource(element);\n  }\n  createMediaStreamDestination() {\n    assert(isAudioContext(this._context), \"Not available if OfflineAudioContext\");\n    const context = this._context;\n    return context.createMediaStreamDestination();\n  }\n  decodeAudioData(audioData) {\n    return this._context.decodeAudioData(audioData);\n  }\n  /**\n   * The current time in seconds of the AudioContext.\n   */\n  get currentTime() {\n    return this._context.currentTime;\n  }\n  /**\n   * The current time in seconds of the AudioContext.\n   */\n  get state() {\n    return this._context.state;\n  }\n  /**\n   * The current time in seconds of the AudioContext.\n   */\n  get sampleRate() {\n    return this._context.sampleRate;\n  }\n  /**\n   * The listener\n   */\n  get listener() {\n    this.initialize();\n    return this._listener;\n  }\n  set listener(l) {\n    assert(!this._initialized, \"The listener cannot be set after initialization.\");\n    this._listener = l;\n  }\n  /**\n   * There is only one Transport per Context. It is created on initialization.\n   */\n  get transport() {\n    this.initialize();\n    return this._transport;\n  }\n  set transport(t) {\n    assert(!this._initialized, \"The transport cannot be set after initialization.\");\n    this._transport = t;\n  }\n  /**\n   * This is the Draw object for the context which is useful for synchronizing the draw frame with the Tone.js clock.\n   */\n  get draw() {\n    this.initialize();\n    return this._draw;\n  }\n  set draw(d) {\n    assert(!this._initialized, \"Draw cannot be set after initialization.\");\n    this._draw = d;\n  }\n  /**\n   * A reference to the Context's destination node.\n   */\n  get destination() {\n    this.initialize();\n    return this._destination;\n  }\n  set destination(d) {\n    assert(!this._initialized, \"The destination cannot be set after initialization.\");\n    this._destination = d;\n  }\n  /**\n   * Create an audio worklet node from a name and options. The module\n   * must first be loaded using [[addAudioWorkletModule]].\n   */\n  createAudioWorkletNode(name, options) {\n    return createAudioWorkletNode(this.rawContext, name, options);\n  }\n  /**\n   * Add an AudioWorkletProcessor module\n   * @param url The url of the module\n   * @param name The name of the module\n   */\n  addAudioWorkletModule(url, name) {\n    return __awaiter(this, void 0, void 0, function* () {\n      assert(isDefined(this.rawContext.audioWorklet), \"AudioWorkletNode is only available in a secure context (https or localhost)\");\n      if (!this._workletModules.has(name)) {\n        this._workletModules.set(name, this.rawContext.audioWorklet.addModule(url));\n      }\n      yield this._workletModules.get(name);\n    });\n  }\n  /**\n   * Returns a promise which resolves when all of the worklets have been loaded on this context\n   */\n  workletsAreReady() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const promises = [];\n      this._workletModules.forEach(promise => promises.push(promise));\n      yield Promise.all(promises);\n    });\n  }\n  //---------------------------\n  // TICKER\n  //---------------------------\n  /**\n   * How often the interval callback is invoked.\n   * This number corresponds to how responsive the scheduling\n   * can be. context.updateInterval + context.lookAhead gives you the\n   * total latency between scheduling an event and hearing it.\n   */\n  get updateInterval() {\n    return this._ticker.updateInterval;\n  }\n  set updateInterval(interval) {\n    this._ticker.updateInterval = interval;\n  }\n  /**\n   * What the source of the clock is, either \"worker\" (default),\n   * \"timeout\", or \"offline\" (none).\n   */\n  get clockSource() {\n    return this._ticker.type;\n  }\n  set clockSource(type) {\n    this._ticker.type = type;\n  }\n  /**\n   * The type of playback, which affects tradeoffs between audio\n   * output latency and responsiveness.\n   * In addition to setting the value in seconds, the latencyHint also\n   * accepts the strings \"interactive\" (prioritizes low latency),\n   * \"playback\" (prioritizes sustained playback), \"balanced\" (balances\n   * latency and performance).\n   * @example\n   * // prioritize sustained playback\n   * const context = new Tone.Context({ latencyHint: \"playback\" });\n   * // set this context as the global Context\n   * Tone.setContext(context);\n   * // the global context is gettable with Tone.getContext()\n   * console.log(Tone.getContext().latencyHint);\n   */\n  get latencyHint() {\n    return this._latencyHint;\n  }\n  /**\n   * Update the lookAhead and updateInterval based on the latencyHint\n   */\n  _setLatencyHint(hint) {\n    let lookAheadValue = 0;\n    this._latencyHint = hint;\n    if (isString(hint)) {\n      switch (hint) {\n        case \"interactive\":\n          lookAheadValue = 0.1;\n          break;\n        case \"playback\":\n          lookAheadValue = 0.5;\n          break;\n        case \"balanced\":\n          lookAheadValue = 0.25;\n          break;\n      }\n    }\n    this.lookAhead = lookAheadValue;\n    this.updateInterval = lookAheadValue / 2;\n  }\n  /**\n   * The unwrapped AudioContext or OfflineAudioContext\n   */\n  get rawContext() {\n    return this._context;\n  }\n  /**\n   * The current audio context time plus a short [[lookAhead]].\n   */\n  now() {\n    return this._context.currentTime + this.lookAhead;\n  }\n  /**\n   * The current audio context time without the [[lookAhead]].\n   * In most cases it is better to use [[now]] instead of [[immediate]] since\n   * with [[now]] the [[lookAhead]] is applied equally to _all_ components including internal components,\n   * to making sure that everything is scheduled in sync. Mixing [[now]] and [[immediate]]\n   * can cause some timing issues. If no lookAhead is desired, you can set the [[lookAhead]] to `0`.\n   */\n  immediate() {\n    return this._context.currentTime;\n  }\n  /**\n   * Starts the audio context from a suspended state. This is required\n   * to initially start the AudioContext. See [[Tone.start]]\n   */\n  resume() {\n    if (isAudioContext(this._context)) {\n      return this._context.resume();\n    } else {\n      return Promise.resolve();\n    }\n  }\n  /**\n   * Close the context. Once closed, the context can no longer be used and\n   * any AudioNodes created from the context will be silent.\n   */\n  close() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (isAudioContext(this._context)) {\n        yield this._context.close();\n      }\n      if (this._initialized) {\n        closeContext(this);\n      }\n    });\n  }\n  /**\n   * **Internal** Generate a looped buffer at some constant value.\n   */\n  getConstant(val) {\n    if (this._constants.has(val)) {\n      return this._constants.get(val);\n    } else {\n      const buffer = this._context.createBuffer(1, 128, this._context.sampleRate);\n      const arr = buffer.getChannelData(0);\n      for (let i = 0; i < arr.length; i++) {\n        arr[i] = val;\n      }\n      const constant = this._context.createBufferSource();\n      constant.channelCount = 1;\n      constant.channelCountMode = \"explicit\";\n      constant.buffer = buffer;\n      constant.loop = true;\n      constant.start(0);\n      this._constants.set(val, constant);\n      return constant;\n    }\n  }\n  /**\n   * Clean up. Also closes the audio context.\n   */\n  dispose() {\n    super.dispose();\n    this._ticker.dispose();\n    this._timeouts.dispose();\n    Object.keys(this._constants).map(val => this._constants[val].disconnect());\n    return this;\n  }\n  //---------------------------\n  // TIMEOUTS\n  //---------------------------\n  /**\n   * The private loop which keeps track of the context scheduled timeouts\n   * Is invoked from the clock source\n   */\n  _timeoutLoop() {\n    const now = this.now();\n    let firstEvent = this._timeouts.peek();\n    while (this._timeouts.length && firstEvent && firstEvent.time <= now) {\n      // invoke the callback\n      firstEvent.callback();\n      // shift the first event off\n      this._timeouts.shift();\n      // get the next one\n      firstEvent = this._timeouts.peek();\n    }\n  }\n  /**\n   * A setTimeout which is guaranteed by the clock source.\n   * Also runs in the offline context.\n   * @param  fn       The callback to invoke\n   * @param  timeout  The timeout in seconds\n   * @returns ID to use when invoking Context.clearTimeout\n   */\n  setTimeout(fn, timeout) {\n    this._timeoutIds++;\n    const now = this.now();\n    this._timeouts.add({\n      callback: fn,\n      id: this._timeoutIds,\n      time: now + timeout\n    });\n    return this._timeoutIds;\n  }\n  /**\n   * Clears a previously scheduled timeout with Tone.context.setTimeout\n   * @param  id  The ID returned from setTimeout\n   */\n  clearTimeout(id) {\n    this._timeouts.forEach(event => {\n      if (event.id === id) {\n        this._timeouts.remove(event);\n      }\n    });\n    return this;\n  }\n  /**\n   * Clear the function scheduled by [[setInterval]]\n   */\n  clearInterval(id) {\n    return this.clearTimeout(id);\n  }\n  /**\n   * Adds a repeating event to the context's callback clock\n   */\n  setInterval(fn, interval) {\n    const id = ++this._timeoutIds;\n    const intervalFn = () => {\n      const now = this.now();\n      this._timeouts.add({\n        callback: () => {\n          // invoke the callback\n          fn();\n          // invoke the event to repeat it\n          intervalFn();\n        },\n        id,\n        time: now + interval\n      });\n    };\n    // kick it off\n    intervalFn();\n    return id;\n  }\n}","map":{"version":3,"mappings":"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","names":["Ticker","isAudioContext","optionsFromArguments","Timeline","isDefined","isString","createAudioContext","createAudioWorkletNode","closeContext","initializeContext","BaseContext","assert","Context","constructor","Map","options","getDefaults","arguments","context","_context","latencyHint","_ticker","emit","bind","clockSource","updateInterval","on","_timeoutLoop","onstatechange","state","_setLatencyHint","lookAhead","initialize","_initialized","createAnalyser","createOscillator","createBufferSource","createBiquadFilter","createBuffer","numberOfChannels","length","sampleRate","createChannelMerger","numberOfInputs","createChannelSplitter","numberOfOutputs","createConstantSource","createConvolver","createDelay","maxDelayTime","createDynamicsCompressor","createGain","createIIRFilter","feedForward","feedback","createPanner","createPeriodicWave","real","imag","constraints","createStereoPanner","createWaveShaper","createMediaStreamSource","stream","createMediaElementSource","element","createMediaStreamDestination","decodeAudioData","audioData","currentTime","listener","_listener","l","transport","_transport","t","draw","_draw","d","destination","_destination","name","rawContext","addAudioWorkletModule","url","audioWorklet","_workletModules","has","set","addModule","get","workletsAreReady","promises","forEach","promise","push","Promise","all","interval","type","_latencyHint","hint","lookAheadValue","now","immediate","resume","resolve","close","getConstant","val","_constants","buffer","arr","getChannelData","i","constant","channelCount","channelCountMode","loop","start","dispose","_timeouts","Object","keys","map","disconnect","firstEvent","peek","time","callback","shift","setTimeout","fn","timeout","_timeoutIds","add","id","clearTimeout","event","remove","clearInterval","setInterval","intervalFn"],"sourceRoot":"","sources":["../../../../Tone/core/context/Context.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module","externalDependencies":[]}