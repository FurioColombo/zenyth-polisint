{"ast":null,"code":"import _regeneratorRuntime from \"/Users/eliapirrello/Documents/GitHub/zenyth/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _classCallCheck from \"/Users/eliapirrello/Documents/GitHub/zenyth/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/eliapirrello/Documents/GitHub/zenyth/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"/Users/eliapirrello/Documents/GitHub/zenyth/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _get from \"/Users/eliapirrello/Documents/GitHub/zenyth/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/eliapirrello/Documents/GitHub/zenyth/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/eliapirrello/Documents/GitHub/zenyth/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/eliapirrello/Documents/GitHub/zenyth/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.array.find.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport { __awaiter } from \"tslib\";\nimport { connect, ToneAudioNode } from \"../core/context/ToneAudioNode\";\nimport { Volume } from \"../component/channel/Volume\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { assert } from \"../core/util/Debug\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { isDefined, isNumber } from \"../core/util/TypeCheck\";\n/**\n * UserMedia uses MediaDevices.getUserMedia to open up and external microphone or audio input.\n * Check [MediaDevices API Support](https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia)\n * to see which browsers are supported. Access to an external input\n * is limited to secure (HTTPS) connections.\n * @example\n * const meter = new Tone.Meter();\n * const mic = new Tone.UserMedia().connect(meter);\n * mic.open().then(() => {\n * \t// promise resolves when input is available\n * \tconsole.log(\"mic open\");\n * \t// print the incoming mic levels in decibels\n * \tsetInterval(() => console.log(meter.getValue()), 100);\n * }).catch(e => {\n * \t// promise is rejected when the user doesn't have or allow mic access\n * \tconsole.log(\"mic not open\");\n * });\n * @category Source\n */\nexport var UserMedia = /*#__PURE__*/function (_ToneAudioNode) {\n  _inherits(UserMedia, _ToneAudioNode);\n  var _super = _createSuper(UserMedia);\n  function UserMedia() {\n    var _this;\n    _classCallCheck(this, UserMedia);\n    _this = _super.call(this, optionsFromArguments(UserMedia.getDefaults(), arguments, [\"volume\"]));\n    _this.name = \"UserMedia\";\n    var options = optionsFromArguments(UserMedia.getDefaults(), arguments, [\"volume\"]);\n    _this._volume = _this.output = new Volume({\n      context: _this.context,\n      volume: options.volume\n    });\n    _this.volume = _this._volume.volume;\n    readOnly(_assertThisInitialized(_this), \"volume\");\n    _this.mute = options.mute;\n    return _this;\n  }\n  _createClass(UserMedia, [{\n    key: \"open\",\n    value:\n    /**\n     * Open the media stream. If a string is passed in, it is assumed\n     * to be the label or id of the stream, if a number is passed in,\n     * it is the input number of the stream.\n     * @param  labelOrId The label or id of the audio input media device.\n     *                   With no argument, the default stream is opened.\n     * @return The promise is resolved when the stream is open.\n     */\n    function open(labelOrId) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var devices, constraints, stream, mediaStreamNode;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              assert(UserMedia.supported, \"UserMedia is not supported\");\n              // close the previous stream\n              if (this.state === \"started\") {\n                this.close();\n              }\n              _context.next = 4;\n              return UserMedia.enumerateDevices();\n            case 4:\n              devices = _context.sent;\n              if (isNumber(labelOrId)) {\n                this._device = devices[labelOrId];\n              } else {\n                this._device = devices.find(function (device) {\n                  return device.label === labelOrId || device.deviceId === labelOrId;\n                });\n                // didn't find a matching device\n                if (!this._device && devices.length > 0) {\n                  this._device = devices[0];\n                }\n                assert(isDefined(this._device), \"No matching device \".concat(labelOrId));\n              }\n              // do getUserMedia\n              constraints = {\n                audio: {\n                  echoCancellation: false,\n                  sampleRate: this.context.sampleRate,\n                  noiseSuppression: false,\n                  mozNoiseSuppression: false\n                }\n              };\n              if (this._device) {\n                // @ts-ignore\n                constraints.audio.deviceId = this._device.deviceId;\n              }\n              _context.next = 10;\n              return navigator.mediaDevices.getUserMedia(constraints);\n            case 10:\n              stream = _context.sent;\n              // start a new source only if the previous one is closed\n              if (!this._stream) {\n                this._stream = stream;\n                // Wrap a MediaStreamSourceNode around the live input stream.\n                mediaStreamNode = this.context.createMediaStreamSource(stream); // Connect the MediaStreamSourceNode to a gate gain node\n                connect(mediaStreamNode, this.output);\n                this._mediaStream = mediaStreamNode;\n              }\n              return _context.abrupt(\"return\", this);\n            case 13:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n    }\n    /**\n     * Close the media stream\n     */\n  }, {\n    key: \"close\",\n    value: function close() {\n      if (this._stream && this._mediaStream) {\n        this._stream.getAudioTracks().forEach(function (track) {\n          track.stop();\n        });\n        this._stream = undefined;\n        // remove the old media stream\n        this._mediaStream.disconnect();\n        this._mediaStream = undefined;\n      }\n      this._device = undefined;\n      return this;\n    }\n    /**\n     * Returns a promise which resolves with the list of audio input devices available.\n     * @return The promise that is resolved with the devices\n     * @example\n     * Tone.UserMedia.enumerateDevices().then((devices) => {\n     * \t// print the device labels\n     * \tconsole.log(devices.map(device => device.label));\n     * });\n     */\n  }, {\n    key: \"state\",\n    get:\n    /**\n     * Returns the playback state of the source, \"started\" when the microphone is open\n     * and \"stopped\" when the mic is closed.\n     */\n    function get() {\n      return this._stream && this._stream.active ? \"started\" : \"stopped\";\n    }\n    /**\n     * Returns an identifier for the represented device that is\n     * persisted across sessions. It is un-guessable by other applications and\n     * unique to the origin of the calling application. It is reset when the\n     * user clears cookies (for Private Browsing, a different identifier is\n     * used that is not persisted across sessions). Returns undefined when the\n     * device is not open.\n     */\n  }, {\n    key: \"deviceId\",\n    get: function get() {\n      if (this._device) {\n        return this._device.deviceId;\n      } else {\n        return undefined;\n      }\n    }\n    /**\n     * Returns a group identifier. Two devices have the\n     * same group identifier if they belong to the same physical device.\n     * Returns null  when the device is not open.\n     */\n  }, {\n    key: \"groupId\",\n    get: function get() {\n      if (this._device) {\n        return this._device.groupId;\n      } else {\n        return undefined;\n      }\n    }\n    /**\n     * Returns a label describing this device (for example \"Built-in Microphone\").\n     * Returns undefined when the device is not open or label is not available\n     * because of permissions.\n     */\n  }, {\n    key: \"label\",\n    get: function get() {\n      if (this._device) {\n        return this._device.label;\n      } else {\n        return undefined;\n      }\n    }\n    /**\n     * Mute the output.\n     * @example\n     * const mic = new Tone.UserMedia();\n     * mic.open().then(() => {\n     * \t// promise resolves when input is available\n     * });\n     * // mute the output\n     * mic.mute = true;\n     */\n  }, {\n    key: \"mute\",\n    get: function get() {\n      return this._volume.mute;\n    },\n    set: function set(mute) {\n      this._volume.mute = mute;\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(UserMedia.prototype), \"dispose\", this).call(this);\n      this.close();\n      this._volume.dispose();\n      this.volume.dispose();\n      return this;\n    }\n    /**\n     * If getUserMedia is supported by the browser.\n     */\n  }], [{\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return Object.assign(ToneAudioNode.getDefaults(), {\n        mute: false,\n        volume: 0\n      });\n    }\n  }, {\n    key: \"enumerateDevices\",\n    value: function enumerateDevices() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var allDevices;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.next = 2;\n              return navigator.mediaDevices.enumerateDevices();\n            case 2:\n              allDevices = _context2.sent;\n              return _context2.abrupt(\"return\", allDevices.filter(function (device) {\n                return device.kind === \"audioinput\";\n              }));\n            case 4:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2);\n      }));\n    }\n  }, {\n    key: \"supported\",\n    get: function get() {\n      return isDefined(navigator.mediaDevices) && isDefined(navigator.mediaDevices.getUserMedia);\n    }\n  }]);\n  return UserMedia;\n}(ToneAudioNode);","map":{"version":3,"mappings":"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","names":["connect","ToneAudioNode","Volume","optionsFromArguments","assert","readOnly","isDefined","isNumber","UserMedia","getDefaults","arguments","options","_volume","output","context","volume","mute","labelOrId","supported","state","close","enumerateDevices","devices","_device","find","device","label","deviceId","length","constraints","audio","echoCancellation","sampleRate","noiseSuppression","mozNoiseSuppression","navigator","mediaDevices","getUserMedia","stream","_stream","mediaStreamNode","createMediaStreamSource","_mediaStream","getAudioTracks","forEach","track","stop","undefined","disconnect","active","groupId","dispose","Object","assign","allDevices","filter","kind"],"sourceRoot":"","sources":["../../../Tone/source/UserMedia.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module","externalDependencies":[]}