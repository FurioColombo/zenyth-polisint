{"ast":null,"code":"import { ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { Split } from \"../channel/Split\";\nimport { Gain } from \"../../core/context/Gain\";\nimport { assert, assertRange } from \"../../core/util/Debug\";\n/**\n * Wrapper around the native Web Audio's [AnalyserNode](http://webaudio.github.io/web-audio-api/#idl-def-AnalyserNode).\n * Extracts FFT or Waveform data from the incoming signal.\n * @category Component\n */\nexport class Analyser extends ToneAudioNode {\n  constructor() {\n    super(optionsFromArguments(Analyser.getDefaults(), arguments, [\"type\", \"size\"]));\n    this.name = \"Analyser\";\n    /**\n     * The analyser node.\n     */\n    this._analysers = [];\n    /**\n     * The buffer that the FFT data is written to\n     */\n    this._buffers = [];\n    const options = optionsFromArguments(Analyser.getDefaults(), arguments, [\"type\", \"size\"]);\n    this.input = this.output = this._gain = new Gain({\n      context: this.context\n    });\n    this._split = new Split({\n      context: this.context,\n      channels: options.channels\n    });\n    this.input.connect(this._split);\n    assertRange(options.channels, 1);\n    // create the analysers\n    for (let channel = 0; channel < options.channels; channel++) {\n      this._analysers[channel] = this.context.createAnalyser();\n      this._split.connect(this._analysers[channel], channel, 0);\n    }\n    // set the values initially\n    this.size = options.size;\n    this.type = options.type;\n  }\n  static getDefaults() {\n    return Object.assign(ToneAudioNode.getDefaults(), {\n      size: 1024,\n      smoothing: 0.8,\n      type: \"fft\",\n      channels: 1\n    });\n  }\n  /**\n   * Run the analysis given the current settings. If [[channels]] = 1,\n   * it will return a Float32Array. If [[channels]] > 1, it will\n   * return an array of Float32Arrays where each index in the array\n   * represents the analysis done on a channel.\n   */\n  getValue() {\n    this._analysers.forEach((analyser, index) => {\n      const buffer = this._buffers[index];\n      if (this._type === \"fft\") {\n        analyser.getFloatFrequencyData(buffer);\n      } else if (this._type === \"waveform\") {\n        analyser.getFloatTimeDomainData(buffer);\n      }\n    });\n    if (this.channels === 1) {\n      return this._buffers[0];\n    } else {\n      return this._buffers;\n    }\n  }\n  /**\n   * The size of analysis. This must be a power of two in the range 16 to 16384.\n   */\n  get size() {\n    return this._analysers[0].frequencyBinCount;\n  }\n  set size(size) {\n    this._analysers.forEach((analyser, index) => {\n      analyser.fftSize = size * 2;\n      this._buffers[index] = new Float32Array(size);\n    });\n  }\n  /**\n   * The number of channels the analyser does the analysis on. Channel\n   * separation is done using [[Split]]\n   */\n  get channels() {\n    return this._analysers.length;\n  }\n  /**\n   * The analysis function returned by analyser.getValue(), either \"fft\" or \"waveform\".\n   */\n  get type() {\n    return this._type;\n  }\n  set type(type) {\n    assert(type === \"waveform\" || type === \"fft\", `Analyser: invalid type: ${type}`);\n    this._type = type;\n  }\n  /**\n   * 0 represents no time averaging with the last analysis frame.\n   */\n  get smoothing() {\n    return this._analysers[0].smoothingTimeConstant;\n  }\n  set smoothing(val) {\n    this._analysers.forEach(a => a.smoothingTimeConstant = val);\n  }\n  /**\n   * Clean up.\n   */\n  dispose() {\n    super.dispose();\n    this._analysers.forEach(a => a.disconnect());\n    this._split.dispose();\n    this._gain.dispose();\n    return this;\n  }\n}","map":{"version":3,"mappings":"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","names":["ToneAudioNode","optionsFromArguments","Split","Gain","assert","assertRange","Analyser","constructor","getDefaults","arguments","options","input","output","_gain","context","_split","channels","connect","channel","_analysers","createAnalyser","size","type","Object","assign","smoothing","getValue","forEach","analyser","index","buffer","_buffers","_type","getFloatFrequencyData","getFloatTimeDomainData","frequencyBinCount","fftSize","Float32Array","length","smoothingTimeConstant","val","a","dispose","disconnect"],"sourceRoot":"","sources":["../../../../Tone/component/analysis/Analyser.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module","externalDependencies":[]}