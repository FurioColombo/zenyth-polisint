{"ast":null,"code":"import _classCallCheck from \"/Users/eliapirrello/Documents/GitHub/zenyth/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/eliapirrello/Documents/GitHub/zenyth/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport { Synth, Envelope, Gain, Meter, Frequency, LFO } from 'tone';\nimport { nextTick } from 'vue';\nimport * as Tone from 'tone';\nimport { isProxy, toRaw } from 'vue';\nvar max_partials_num = 50;\nvar vol_damp_factor = 0.5;\nvar MyPolySynth = /*#__PURE__*/function () {\n  function MyPolySynth() {\n    var destination = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    var nVoices = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 16;\n    _classCallCheck(this, MyPolySynth);\n    this.destination = destination;\n\n    //data of all modulators that could potentially be linked to the parameters of the synth\n    this.modulatorsData = {\n      envelope: {\n        vol: {\n          amount: 1,\n          parameters: {\n            attack: 1,\n            decay: 0.3,\n            sustain: 0.8,\n            release: 1\n          }\n        },\n        mod: {\n          amount: 0,\n          parameters: {\n            attack: 0.05,\n            decay: 0.1,\n            sustain: 1,\n            release: 0.2\n          }\n        },\n        pitch: {\n          amount: 0,\n          parameters: {\n            attack: 0.05,\n            decay: 0.1,\n            sustain: 1,\n            release: 0.2\n          }\n        }\n      },\n      lfo: {\n        vol: {\n          amount: 0,\n          parameters: {\n            frequency: 10,\n            waveform: \"sine\",\n            min: 0,\n            max: 1\n          }\n        },\n        mod: {\n          amount: 0,\n          parameters: {\n            frequency: 10,\n            waveform: \"sine\",\n            min: 0,\n            max: 1\n          }\n        },\n        pitch: {\n          amount: 0,\n          parameters: {\n            frequency: 10,\n            waveform: \"sine\",\n            min: 0,\n            max: 1\n          }\n        }\n      }\n    };\n\n    //preset with which all voices of polyphony will be created\n    this.synthPreset = {\n      type: \"\",\n      waveform: \"sine\",\n      vol: -12,\n      transpose: 0,\n      mod: 0,\n      partials: \"\",\n      pan: \"\"\n    };\n\n    //modulation effect\n    //this.crusher = new Tone.BitCrusher(3)\n\n    this.dampNode = new Gain(vol_damp_factor);\n    //all polyphony voices are connected here\n\n    //console.log(Tone.dbToGain(this.synthPreset.vol))\n    this.gainNode = new Gain(1);\n\n    //list of polyphony voices\n    this.allVoices = []; //always holds reference to all voices\n    this.freeVoices = []; //holds reference to free voices\n    this.busyVoices = {}; //holds reference to busy voices, key=note, value=voice\n    this.nVoices = nVoices; //used to initialize, taken from globalProperties\n    this.lastNotes = Array(this.nVoices); //stores last nVoices played\n\n    //INIT VOICES\n    this.initVoices();\n\n    // connect gainNode to destination\n    this.gainNode.connect(this.dampNode);\n    //this.crusher.connect(this.dampNode)\n    this.dampNode.connect(this.destination);\n  }\n  _createClass(MyPolySynth, [{\n    key: \"initVoices\",\n    value: function initVoices() {\n      //for each voice\n\n      for (var index = 0; index < this.nVoices; index++) {\n        //initializing empty modulators matrix\n        var modulators = {\n          envelope: {\n            vol: {\n              amount: 1,\n              signal: null,\n              scale: null\n            },\n            mod: {\n              amount: 0,\n              signal: null,\n              scale: null\n            },\n            pitch: {\n              amount: 0,\n              signal: null,\n              scale: null\n            }\n          },\n          lfo: {\n            vol: {\n              amount: 0,\n              signal: null,\n              scale: null\n            },\n            mod: {\n              amount: 0,\n              signal: null,\n              scale: null\n            },\n            pitch: {\n              amount: 0,\n              signal: null,\n              scale: null\n            }\n          }\n        };\n        var lfoGain = new Gain();\n        lfoGain.connect(this.gainNode); //USED TO CONNECT LFO TO VOICE VOLUME\n\n        //creating gain and synth\n        var gain = new Gain(1).connect(lfoGain);\n        //synth is created and initialized with preset parameters\n        var synth = this.createSynth();\n        synth.oscillator.disconnect();\n        synth.oscillator.connect(gain);\n\n        //disconnect and dispose synth inner envelope\n        synth.envelope.disconnect();\n        synth.envelope.dispose();\n\n        //thanks to noiseAdsrGain we can lower to zero the volume of the synth and still hear the noise, bypassing the synth volume\n        var noiseAdsrGain = new Gain(); //used to have the same main adsr of synth on the noise too\n        var noiseGain = new Gain();\n        var noise = new Tone.Noise(\"pink\");\n        noise.connect(noiseGain);\n        noiseGain.connect(noiseAdsrGain);\n        noiseAdsrGain.connect(this.dampNode);\n        var voice = {\n          synth: synth,\n          gain: gain,\n          lfoGain: lfoGain,\n          modulators: modulators,\n          noise: noise,\n          noiseGain: noiseGain,\n          noiseAdsrGain: noiseAdsrGain\n        };\n\n        //creating and connecting every modulator\n        for (var type in modulators) {\n          for (var target in modulators[type]) {\n            var tempMod = this.createModulator(type);\n            modulators[type][target].signal = tempMod;\n            modulators[type][target].scale = this.createScale(target);\n            this.connectModulator(modulators[type][target], type, target, voice);\n          }\n        }\n        //pushing voice into freeVoices array\n        this.freeVoices.push(voice);\n        this.allVoices.push(voice);\n      }\n      this.initialized = false;\n      //setting all parameters of modulators\n      this.updateModulators();\n      this.initialized = true;\n    }\n  }, {\n    key: \"playNote\",\n    value: function playNote(note, velocity) {\n      //console.log(this.freeVoices)\n      if (this.initialized) {\n        this.lastNotes.push(note);\n        if (this.lastNotes.length > this.nVoices) {\n          this.lastNote = this.lastNotes.shift();\n        }\n\n        //removing first free voice from array\n        var voice = this.freeVoices.shift();\n        if (!voice) {\n          //console.log(\"NEW NOTE OVERWRITE: \" + this.lastNote)\n          voice = this.busyVoices[this.lastNote];\n          delete this.busyVoices[this.lastNote];\n        }\n        this.busyVoices[note] = voice;\n\n        //trigger attack in each modulator\n        for (var type in voice.modulators) {\n          for (var target in voice.modulators[type]) {\n            if (voice.modulators[type][target].amount > 0) {\n              switch (type) {\n                case \"envelope\":\n                  //console.log(\"TRIGGERING ATTACK IN \"+type+\" connected to \"+target)\n                  //console.log(voice.modulators[type][target].signal)\n                  toRaw(voice.modulators[type][target].signal).cancel(Tone.now());\n                  toRaw(voice.modulators[type][target].signal).triggerAttack(Tone.now());\n                  break;\n                case \"lfo\":\n                  toRaw(voice.modulators[type][target]).signal.stop();\n                  toRaw(voice.modulators[type][target]).signal.start();\n                  break;\n                default:\n                  break;\n              }\n            }\n          }\n        }\n        voice.synth.oscillator.stop(Tone.now());\n        voice.synth.envelope.cancel(Tone.now());\n        //trigger attack in synth and noise\n        voice.noise.start();\n        voice.synth.triggerAttack(note, Tone.now(), velocity / 128);\n      }\n    }\n  }, {\n    key: \"stopNote\",\n    value: function stopNote(note) {\n      if (this.initialized) {\n        if (this.busyVoices[note]) {\n          var voice = this.busyVoices[note];\n          delete this.busyVoices[note];\n          this.freeVoices.push(voice);\n\n          //triggerRelease on all envelopes\n          for (var type in voice.modulators) {\n            for (var target in voice.modulators[type]) {\n              if (voice.modulators[type][target].signal) {\n                switch (type) {\n                  case \"envelope\":\n                    //console.log(\"Triggering release of \"+type+\" with target \"+target)\n                    voice.modulators[type][target].signal.triggerRelease(Tone.now());\n                    break;\n                  case \"lfo\":\n                    //lfos are never stopped, just diminished in amount if needed\n                    //fvoice.modulators[type][target].signal.stop()\n                    break;\n                  default:\n                    break;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }, {\n    key: \"createSynth\",\n    value: function createSynth() {\n      var _this = this;\n      var synth = new Synth();\n      //Setting parameters\n      nextTick(function () {\n        synth.set({\n          \"volume\": _this.synthPreset.vol,\n          \"detune\": _this.synthPreset.transpose * 100,\n          \"oscillator\": {\n            \"type\": _this.synthPreset.type + _this.synthPreset.waveform + _this.synthPreset.partials\n          }\n        });\n      });\n      //console.log(this.synthPreset.type + this.synthPreset.waveform + this.synthPreset.partials)\n\n      return synth;\n    }\n  }, {\n    key: \"createModulator\",\n    value: function createModulator(type) {\n      //console.log(\"creating modulator of type: \"+type)\n      switch (type) {\n        case \"envelope\":\n          return new Envelope();\n        case \"lfo\":\n          return new LFO();\n        default:\n          console.log(\"Error creating modulator\");\n          return null;\n      }\n    }\n  }, {\n    key: \"createScale\",\n    value: function createScale(target) {\n      switch (target) {\n        case \"vol\":\n          return new Tone.Scale(0, 1);\n        case \"mod\":\n          return new Tone.Scale(0, 1);\n        case \"pitch\":\n          return new Tone.Scale(0, 1);\n        case \"pan\":\n          return new Tone.Scale(0, 1);\n        default:\n          console.log(\"Error creating scale for target \" + target);\n          return null;\n      }\n    }\n  }, {\n    key: \"updateModulators\",\n    value: function updateModulators() {\n      var _this2 = this;\n      this.allVoices.forEach(function (voice) {\n        for (var type in voice.modulators) {\n          for (var target in voice.modulators[type]) {\n            //update amount from preset\n            voice.modulators[type][target].amount = _this2.modulatorsData[type][target].amount;\n            if (!toRaw(voice.modulators[type][target].signal)) {\n              //IF IT'S STILL NOT CREATED\n              //console.log(\"RECREATING\")\n              voice.modulators[type][target].signal = _this2.createModulator(type);\n              voice.modulators[type][target].scale = _this2.createScale(target);\n              _this2.connectModulator(toRaw(voice.modulators[type][target]), type, target, toRaw(voice));\n              //console.log(voice.modulators[type][target])\n            }\n\n            _this2.scaleSetter(voice.modulators[type][target], target);\n            _this2.modulatorSetter(toRaw(voice.modulators[type][target].signal), type, _this2.modulatorsData[type][target].parameters);\n          }\n        }\n      });\n    }\n  }, {\n    key: \"updateSynths\",\n    value: function updateSynths() {\n      var _this3 = this;\n      this.allVoices.forEach(function (voice) {\n        voice.synth.set({\n          \"detune\": _this3.synthPreset.transpose * 100,\n          \"oscillator\": {\n            \"type\": _this3.synthPreset.type + _this3.synthPreset.waveform + _this3.synthPreset.partials\n          }\n        });\n        //this.gainNode.set({gain: Tone.dbToGain(this.synthPreset.vol)})\n        voice.noiseGain.set({\n          gain: _this3.synthPreset.mod\n        });\n      });\n    }\n  }, {\n    key: \"scaleSetter\",\n    value: function scaleSetter(modulator, target) {\n      switch (target) {\n        case \"vol\":\n          //ENVELOPE FOR VOL SHOULD HAVE SCALE TOO TO CENTER AROUND SELECTED FREQUENCY\n          toRaw(modulator.scale).set({\n            min: Math.max(Tone.dbToGain(this.synthPreset.vol) - modulator.amount, 0),\n            max: Math.min(Tone.dbToGain(this.synthPreset.vol) + modulator.amount, 1)\n          });\n          break;\n        case \"mod\":\n          toRaw(modulator.scale).set({\n            min: Math.max(this.synthPreset.mod - modulator.amount, 0),\n            max: Math.min(this.synthPreset.mod + modulator.amount, 1)\n          });\n          break;\n        case \"pitch\":\n          //TO-DO\n          //console.log(\"CHANGING SCALE \")\n          //console.log(modulator.scale)\n          toRaw(modulator.scale).set({\n            min: (this.synthPreset.transpose - 24 * modulator.amount) * 100,\n            max: (this.synthPreset.transpose + 24 * modulator.amount) * 100\n          });\n          break;\n        case \"pan\":\n          //TO-DO\n          break;\n        default:\n          console.log(\"invalid target to connect modulator to\");\n          break;\n      }\n    }\n  }, {\n    key: \"modulatorSetter\",\n    value: function modulatorSetter(modulator, type, parameters) {\n      if (!toRaw(parameters).waveform) toRaw(parameters).waveform = modulator.type;\n      switch (type) {\n        case \"envelope\":\n          modulator.set({\n            \"attack\": parameters.attack,\n            \"decay\": parameters.decay,\n            \"sustain\": parameters.sustain,\n            \"release\": parameters.release + 0.001\n          });\n          //console.log(\"JUST SET PARAMETERS OF\")\n          //console.log(modulator)\n          //console.log(\"WITH\")\n          //console.log(parameters)\n          break;\n        case \"lfo\":\n          //TO-DO\n          //console.log(\"PARAMETERS\")\n          //console.log(parameters)\n          modulator.set({\n            //\n            \"type\": toRaw(parameters).waveform,\n            \"frequency\": toRaw(parameters).frequency\n          });\n          break;\n        default:\n          console.log(\"Error setting modulator parameters, invalid args\");\n          break;\n      }\n      // console.log(\"modulator.type: \", modulator.type)\n    }\n\n    //have to pass, the modulator (tone), the type (lfo or envelope), the gain linked to the voice, the voice and the target\n  }, {\n    key: \"connectModulator\",\n    value: function connectModulator(modulator, type, target, voice) {\n      //console.log(\"connecting\")\n      //console.log(modulator)\n      //console.log(\"to voice: \")\n      //console.log(voice)\n      //console.log(\"to target: \" + target)\n      switch (type) {\n        case \"envelope\":\n          switch (target) {\n            case \"vol\":\n              modulator.signal.chain(modulator.scale, voice.gain.gain);\n              //modulator.signal.connect(voice.gain.gain)   //SET MAIN ADSR TO SYNTH GAIN\n              modulator.signal.connect(voice.noiseAdsrGain.gain); //SET MAIN ADSR TO NOISE GAIN\n              break;\n            case \"mod\":\n              modulator.signal.chain(modulator.scale, voice.noiseGain.gain);\n              break;\n            case \"pitch\":\n              //TO-DO\n              this.scaleSetter(modulator, target);\n              modulator.signal.chain(modulator.scale, voice.synth.detune);\n              break;\n            case \"pan\":\n              //TO-DO\n              break;\n            default:\n              console.log(\"invalid target to connect modulator to\");\n              break;\n          }\n          break;\n        case \"lfo\":\n          switch (target) {\n            case \"vol\":\n              this.scaleSetter(modulator, target);\n              modulator.signal.chain(modulator.scale, voice.lfoGain.gain);\n              break;\n            case \"mod\":\n              modulator.signal.chain(modulator.scale, voice.noiseGain.gain);\n              break;\n            case \"pitch\":\n              //TO-DO\n              this.scaleSetter(modulator, target);\n              modulator.signal.chain(modulator.scale, voice.synth.detune);\n              break;\n            case \"pan\":\n              //TO-DO\n              break;\n            default:\n              console.log(\"invalid target to connect modulator to\");\n              break;\n          }\n          break;\n        default:\n          console.log(\"invalid modulator type\");\n          break;\n      }\n    }\n\n    // setters\n  }, {\n    key: \"setModulatorParameters\",\n    value: function setModulatorParameters(type, target, parameters) {\n      //console.log(\"myPolysynth - setModulatorParameters\")\n      if (this.initialized) {\n        this.modulatorsData[type][target].parameters = parameters;\n        // console.log(\"New modulatorsData for type \"+type+\" to target \"+target)\n        // console.log(this.modulatorsData);\n        // console.log(\"params: \" , this.modulatorsData[type][target].parameters,  parameters)\n\n        this.updateModulators();\n        //console.log(\"SETTING\")\n        //console.log(this.modulatorsData)\n      }\n    }\n  }, {\n    key: \"setModulatorAmount\",\n    value: function setModulatorAmount(type, target, amount) {\n      if (this.initialized) {\n        this.modulatorsData[type][target].amount = amount;\n        //console.log(\"setting modulator amount\")\n        this.updateModulators();\n      }\n    }\n\n    //TO RENAME IN SET SYNTH PARAMETERS\n  }, {\n    key: \"setParameters\",\n    value: function setParameters(_ref) {\n      var _ref$volume = _ref.volume,\n        volume = _ref$volume === void 0 ? this.synthPreset.vol : _ref$volume,\n        _ref$modulation = _ref.modulation,\n        modulation = _ref$modulation === void 0 ? this.synthPreset.mod : _ref$modulation,\n        _ref$transpose = _ref.transpose,\n        transpose = _ref$transpose === void 0 ? this.synthPreset.transpose : _ref$transpose,\n        _ref$pan = _ref.pan,\n        pan = _ref$pan === void 0 ? this.synthPreset.pan : _ref$pan,\n        _ref$type = _ref.type,\n        type = _ref$type === void 0 ? this.synthPreset.type : _ref$type,\n        _ref$waveform = _ref.waveform,\n        waveform = _ref$waveform === void 0 ? this.synthPreset.waveform : _ref$waveform;\n      if (this.initialized) {\n        this.synthPreset.vol = volume;\n        this.synthPreset.mod = modulation;\n        this.synthPreset.transpose = transpose;\n        this.synthPreset.pan = pan;\n        this.synthPreset.type = type;\n        this.synthPreset.waveform = waveform;\n        //console.log(this.synthPreset.waveform)\n\n        this.updateSynths();\n        this.updateModulators();\n      } else {\n        console.log(\"Polysynth not initialized\");\n      }\n    }\n\n    // connect each voice to the new routing\n  }, {\n    key: \"connect\",\n    value: function connect(route) {\n      this.gainNode.connect(route);\n    }\n  }, {\n    key: \"disconnectDispose\",\n    value: function disconnectDispose() {\n      //for each voice\n      this.allVoices.forEach(function (voice) {\n        //Disconnect and dispose synth\n        voice = toRaw(voice);\n        voice.synth.disconnect();\n        voice.synth.dispose();\n        //Disconnect and dispose gain\n        voice.gain.disconnect();\n        voice.gain.dispose();\n        //Disconnect and dispose modulators\n        for (var type in voice.modulators) {\n          for (var target in voice.modulators[type]) {\n            if (voice.modulators[type][target].signal) {\n              voice.modulators[type][target].signal.disconnect();\n              voice.modulators[type][target].signal.dispose();\n              voice.modulators[type][target].scale.disconnect();\n              voice.modulators[type][target].scale.dispose();\n            }\n          }\n        }\n      });\n      //disconnect and dispose main gainNode\n      this.gainNode.disconnect();\n      this.gainNode.dispose();\n\n      //console.log(\"MyPolySynth completely disconnected and disposed\")\n    }\n  }]);\n  return MyPolySynth;\n}();\nexport { MyPolySynth as default };","map":{"version":3,"names":["Synth","Envelope","Gain","Meter","Frequency","LFO","nextTick","Tone","isProxy","toRaw","max_partials_num","vol_damp_factor","MyPolySynth","destination","nVoices","modulatorsData","envelope","vol","amount","parameters","attack","decay","sustain","release","mod","pitch","lfo","frequency","waveform","min","max","synthPreset","type","transpose","partials","pan","dampNode","gainNode","allVoices","freeVoices","busyVoices","lastNotes","Array","initVoices","connect","index","modulators","signal","scale","lfoGain","gain","synth","createSynth","oscillator","disconnect","dispose","noiseAdsrGain","noiseGain","noise","Noise","voice","target","tempMod","createModulator","createScale","connectModulator","push","initialized","updateModulators","note","velocity","length","lastNote","shift","cancel","now","triggerAttack","stop","start","triggerRelease","set","console","log","Scale","forEach","scaleSetter","modulatorSetter","modulator","Math","dbToGain","chain","detune","volume","modulation","updateSynths","route"],"sources":["/Users/eliapirrello/Documents/GitHub/zenyth/src/views/Synth/Oscillators/MyPolySynth.js"],"sourcesContent":["import {Synth, Envelope, Gain, Meter, Frequency, LFO} from 'tone'\nimport {nextTick} from 'vue';\nimport * as Tone from 'tone'\nimport {isProxy, toRaw} from 'vue';\n\nconst max_partials_num = 50;\nconst vol_damp_factor = 0.5;\n\nexport default class MyPolySynth {\n    constructor(destination = null, nVoices = 16) {\n\n        this.destination = destination;\n\n\n        //data of all modulators that could potentially be linked to the parameters of the synth\n        this.modulatorsData = {\n            envelope: {\n                vol: {\n                    amount: 1,\n                    parameters: {\n                        attack: 1,\n                        decay: 0.3,\n                        sustain: 0.8,\n                        release: 1\n                    }\n                },\n                mod: {\n                    amount: 0,\n                    parameters: {\n                        attack: 0.05,\n                        decay: 0.1,\n                        sustain: 1,\n                        release: 0.2\n                    }\n                },\n                pitch: {\n                    amount: 0,\n                    parameters: {\n                        attack: 0.05,\n                        decay: 0.1,\n                        sustain: 1,\n                        release: 0.2\n                    }\n                },\n            },\n            lfo: {\n                vol: {\n                    amount: 0,\n                    parameters: {\n                        frequency: 10,\n                        waveform: \"sine\",\n                        min: 0,\n                        max: 1\n                    }\n                },\n                mod: {\n                    amount: 0,\n                    parameters: {\n                        frequency: 10,\n                        waveform: \"sine\",\n                        min: 0,\n                        max: 1\n                    }\n                },\n                pitch: {\n                    amount: 0,\n                    parameters: {\n                        frequency: 10,\n                        waveform: \"sine\",\n                        min: 0,\n                        max: 1\n                    }\n                },\n            }\n        }\n\n        //preset with which all voices of polyphony will be created\n        this.synthPreset = {\n            type: \"\",\n            waveform: \"sine\",\n            vol: -12,\n            transpose: 0,\n            mod: 0,\n            partials: \"\",\n            pan: \"\"\n        }\n\n\n        //modulation effect\n        //this.crusher = new Tone.BitCrusher(3)\n\n\n        this.dampNode = new Gain(vol_damp_factor);\n        //all polyphony voices are connected here\n\n        //console.log(Tone.dbToGain(this.synthPreset.vol))\n        this.gainNode = new Gain(1);\n\n        //list of polyphony voices\n        this.allVoices = [] //always holds reference to all voices\n        this.freeVoices = []    //holds reference to free voices\n        this.busyVoices = {}    //holds reference to busy voices, key=note, value=voice\n        this.nVoices = nVoices  //used to initialize, taken from globalProperties\n        this.lastNotes = Array(this.nVoices)  //stores last nVoices played\n\n        //INIT VOICES\n        this.initVoices()\n\n\n        // connect gainNode to destination\n            this.gainNode.connect(this.dampNode)\n            //this.crusher.connect(this.dampNode)\n            this.dampNode.connect(this.destination)\n    }\n\n    initVoices() {\n        //for each voice\n\n        for (let index = 0; index < this.nVoices; index++) {\n\n            //initializing empty modulators matrix\n            let modulators = {\n                envelope: {\n                    vol: {amount: 1, signal: null, scale: null},\n                    mod: {amount: 0, signal: null, scale: null},\n                    pitch: {amount: 0, signal: null, scale: null},\n                },\n                lfo: {\n                    vol: {amount: 0, signal: null, scale: null},\n                    mod: {amount: 0, signal: null, scale: null},\n                    pitch: {amount: 0, signal: null, scale: null},\n                }\n            }\n\n            let lfoGain = new Gain()\n            lfoGain.connect(this.gainNode) //USED TO CONNECT LFO TO VOICE VOLUME\n\n\n            //creating gain and synth\n            let gain = new Gain(1).connect(lfoGain)\n            //synth is created and initialized with preset parameters\n            let synth = this.createSynth()\n            synth.oscillator.disconnect()\n            synth.oscillator.connect(gain)\n\n            //disconnect and dispose synth inner envelope\n            synth.envelope.disconnect()\n            synth.envelope.dispose()\n\n            //thanks to noiseAdsrGain we can lower to zero the volume of the synth and still hear the noise, bypassing the synth volume\n            let noiseAdsrGain = new Gain()  //used to have the same main adsr of synth on the noise too\n            let noiseGain = new Gain()\n            let noise = new Tone.Noise(\"pink\")\n            noise.connect(noiseGain)\n            noiseGain.connect(noiseAdsrGain)\n            noiseAdsrGain.connect(this.dampNode)\n\n\n\n\n            let voice = {synth: synth, gain: gain, lfoGain: lfoGain, modulators: modulators, noise: noise, noiseGain: noiseGain, noiseAdsrGain: noiseAdsrGain}\n\n            //creating and connecting every modulator\n            for (let type in modulators) {\n                for (let target in modulators[type]) {\n                    let tempMod = this.createModulator(type)\n                    modulators[type][target].signal = tempMod\n                    modulators[type][target].scale = this.createScale(target)\n                    this.connectModulator(modulators[type][target], type, target, voice)\n                }\n            }\n            //pushing voice into freeVoices array\n            this.freeVoices.push(voice)\n            this.allVoices.push(voice)\n        }\n\n        this.initialized = false\n        //setting all parameters of modulators\n        this.updateModulators();\n        this.initialized = true\n\n    }\n\n    playNote(note, velocity) {\n        //console.log(this.freeVoices)\n        if (this.initialized) {\n\n            this.lastNotes.push(note);\n            if (this.lastNotes.length > this.nVoices) {\n                this.lastNote = this.lastNotes.shift();\n            }\n\n            //removing first free voice from array\n            let voice = this.freeVoices.shift()\n            if (!voice) {\n                //console.log(\"NEW NOTE OVERWRITE: \" + this.lastNote)\n                voice = this.busyVoices[this.lastNote]\n                delete this.busyVoices[this.lastNote]\n            }\n            this.busyVoices[note] = voice\n\n            //trigger attack in each modulator\n            for (let type in voice.modulators) {\n                for (let target in voice.modulators[type]) {\n                    if (voice.modulators[type][target].amount>0 ) {\n                    switch (type) {\n                        case \"envelope\":\n                            //console.log(\"TRIGGERING ATTACK IN \"+type+\" connected to \"+target)\n                            //console.log(voice.modulators[type][target].signal)\n                            toRaw(voice.modulators[type][target].signal).cancel(Tone.now())\n                            toRaw(voice.modulators[type][target].signal).triggerAttack(Tone.now())\n                            break;\n                        case \"lfo\":\n                            toRaw(voice.modulators[type][target]).signal.stop()\n                            toRaw(voice.modulators[type][target]).signal.start()\n                            break;\n                        default:\n                            break;\n                    }\n                    }\n                }\n            }\n            voice.synth.oscillator.stop(Tone.now())\n            voice.synth.envelope.cancel(Tone.now())\n            //trigger attack in synth and noise\n            voice.noise.start()\n            voice.synth.triggerAttack(note, Tone.now(), velocity / 128)\n        }\n    }\n\n    stopNote(note) {\n        if (this.initialized) {\n            if (this.busyVoices[note]) {\n                let voice = this.busyVoices[note]\n                delete this.busyVoices[note]\n                this.freeVoices.push(voice)\n\n                //triggerRelease on all envelopes\n                for (let type in voice.modulators) {\n                    for (let target in voice.modulators[type]) {\n                        if (voice.modulators[type][target].signal) {\n                            switch (type) {\n                                case \"envelope\":\n                                    //console.log(\"Triggering release of \"+type+\" with target \"+target)\n                                    voice.modulators[type][target].signal.triggerRelease(Tone.now())\n                                    break;\n                                case \"lfo\":\n                                    //lfos are never stopped, just diminished in amount if needed\n                                    //fvoice.modulators[type][target].signal.stop()\n                                    break;\n                                default:\n                                    break;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    createSynth() {\n        let synth = new Synth()\n        //Setting parameters\n        nextTick(() => {\n            synth.set({\n                \"volume\": this.synthPreset.vol,\n                \"detune\": this.synthPreset.transpose * 100,\n                \"oscillator\": {\n                    \"type\": this.synthPreset.type + this.synthPreset.waveform + this.synthPreset.partials\n                }\n            })\n        })\n        //console.log(this.synthPreset.type + this.synthPreset.waveform + this.synthPreset.partials)\n\n        return synth\n    }\n\n    createModulator(type) {\n        //console.log(\"creating modulator of type: \"+type)\n        switch (type) {\n            case \"envelope\":\n                return new Envelope\n            case \"lfo\":\n                return new LFO\n            default:\n                console.log(\"Error creating modulator\")\n                return null\n        }\n    }\n\n    createScale(target) {\n        switch (target) {\n            case \"vol\":\n                return new Tone.Scale(0, 1);\n            case \"mod\":\n                return new Tone.Scale(0, 1);\n            case \"pitch\":\n                return new Tone.Scale(0, 1);\n            case \"pan\":\n                return new Tone.Scale(0, 1);\n            default:\n                console.log(\"Error creating scale for target \"+target)\n                return null\n        }\n    }\n\n    updateModulators() {\n        this.allVoices.forEach(voice => {\n                for (let type in voice.modulators) {\n                    for (let target in voice.modulators[type]) {\n                        //update amount from preset\n                        voice.modulators[type][target].amount = this.modulatorsData[type][target].amount\n                        if (!toRaw(voice.modulators[type][target].signal)) {\n                            //IF IT'S STILL NOT CREATED\n                            //console.log(\"RECREATING\")\n                            voice.modulators[type][target].signal = this.createModulator(type)\n                            voice.modulators[type][target].scale = this.createScale(target)\n                            this.connectModulator(toRaw(voice.modulators[type][target]), type, target, toRaw(voice))\n                            //console.log(voice.modulators[type][target])\n                        }\n                        this.scaleSetter(voice.modulators[type][target], target)\n                        this.modulatorSetter(toRaw(voice.modulators[type][target].signal), type, this.modulatorsData[type][target].parameters)\n                    }\n                }\n            }\n        );\n    }\n\n    updateSynths() {\n        this.allVoices.forEach(voice => {\n            voice.synth.set({\n                \"detune\": this.synthPreset.transpose * 100,\n                \"oscillator\": {\n                    \"type\": this.synthPreset.type + this.synthPreset.waveform + this.synthPreset.partials\n                }\n            })\n            //this.gainNode.set({gain: Tone.dbToGain(this.synthPreset.vol)})\n            voice.noiseGain.set({\n                gain: this.synthPreset.mod\n            })\n        });\n    }\n\n    scaleSetter(modulator, target) {\n        switch (target) {\n            case \"vol\":\n                //ENVELOPE FOR VOL SHOULD HAVE SCALE TOO TO CENTER AROUND SELECTED FREQUENCY\n                toRaw(modulator.scale).set({\n                    min: (Math.max(Tone.dbToGain(this.synthPreset.vol) - modulator.amount,0)),\n                    max: (Math.min(Tone.dbToGain(this.synthPreset.vol) + modulator.amount,1)),\n                })\n\n\n                break;\n            case \"mod\":\n                toRaw(modulator.scale).set({\n                    min: (Math.max(this.synthPreset.mod - modulator.amount,0)),\n                    max: (Math.min(this.synthPreset.mod + modulator.amount,1)),\n                })\n                break;\n            case \"pitch\":\n                //TO-DO\n                //console.log(\"CHANGING SCALE \")\n                //console.log(modulator.scale)\n                toRaw(modulator.scale).set({\n                    min: ((this.synthPreset.transpose - 24 * modulator.amount) * 100),\n                    max: ((this.synthPreset.transpose + 24 * modulator.amount) * 100)\n                })\n                break;\n            case \"pan\":\n                //TO-DO\n                break;\n\n            default:\n                console.log(\"invalid target to connect modulator to\")\n                break;\n        }\n    }\n\n    modulatorSetter(modulator, type, parameters) {\n        if(!toRaw(parameters).waveform) toRaw(parameters).waveform = modulator.type\n\n        switch (type) {\n            case \"envelope\":\n                modulator.set({\n                    \"attack\": parameters.attack,\n                    \"decay\": parameters.decay,\n                    \"sustain\": parameters.sustain,\n                    \"release\": parameters.release + 0.001,\n                })\n                //console.log(\"JUST SET PARAMETERS OF\")\n                //console.log(modulator)\n                //console.log(\"WITH\")\n                //console.log(parameters)\n                break;\n            case \"lfo\":\n                //TO-DO\n                //console.log(\"PARAMETERS\")\n                //console.log(parameters)\n                modulator.set({//\n                    \"type\": toRaw(parameters).waveform,\n                    \"frequency\": toRaw(parameters).frequency\n                })\n                break;\n            default:\n                console.log(\"Error setting modulator parameters, invalid args\")\n                break;\n        }\n        // console.log(\"modulator.type: \", modulator.type)\n    }\n\n//have to pass, the modulator (tone), the type (lfo or envelope), the gain linked to the voice, the voice and the target\n    connectModulator(modulator, type, target, voice) {\n        //console.log(\"connecting\")\n        //console.log(modulator)\n        //console.log(\"to voice: \")\n        //console.log(voice)\n        //console.log(\"to target: \" + target)\n        switch (type) {\n            case \"envelope\":\n                switch (target) {\n                    case \"vol\":\n                        modulator.signal.chain(modulator.scale, voice.gain.gain)\n                        //modulator.signal.connect(voice.gain.gain)   //SET MAIN ADSR TO SYNTH GAIN\n                        modulator.signal.connect(voice.noiseAdsrGain.gain)      //SET MAIN ADSR TO NOISE GAIN\n                        break;\n                    case \"mod\":\n                        modulator.signal.chain(modulator.scale, voice.noiseGain.gain)\n                        break;\n                    case \"pitch\":\n                        //TO-DO\n                        this.scaleSetter(modulator, target)\n                        modulator.signal.chain(modulator.scale, voice.synth.detune)\n                        break;\n                    case \"pan\":\n                        //TO-DO\n                        break;\n                    default:\n                        console.log(\"invalid target to connect modulator to\")\n                        break;\n                }\n\n                break;\n\n            case \"lfo\":\n                switch (target) {\n                    case \"vol\":\n                        this.scaleSetter(modulator, target)\n                        modulator.signal.chain(modulator.scale, voice.lfoGain.gain)\n                        break;\n                    case \"mod\":\n                        modulator.signal.chain(modulator.scale, voice.noiseGain.gain)\n                        break;\n                    case \"pitch\":\n                        //TO-DO\n                        this.scaleSetter(modulator, target)\n                        modulator.signal.chain(modulator.scale, voice.synth.detune)\n                        break;\n                    case \"pan\":\n                        //TO-DO\n                        break;\n                    default:\n                        console.log(\"invalid target to connect modulator to\")\n                        break;\n                }\n\n                break;\n\n            default:\n                console.log(\"invalid modulator type\")\n                break;\n        }\n    }\n\n    // setters\n    setModulatorParameters(type, target, parameters) {\n        //console.log(\"myPolysynth - setModulatorParameters\")\n        if (this.initialized) {\n            this.modulatorsData[type][target].parameters = parameters\n            // console.log(\"New modulatorsData for type \"+type+\" to target \"+target)\n            // console.log(this.modulatorsData);\n            // console.log(\"params: \" , this.modulatorsData[type][target].parameters,  parameters)\n\n            this.updateModulators()\n            //console.log(\"SETTING\")\n            //console.log(this.modulatorsData)\n        }\n    }\n\n    setModulatorAmount(type, target, amount) {\n        if (this.initialized) {\n            this.modulatorsData[type][target].amount = amount\n            //console.log(\"setting modulator amount\")\n            this.updateModulators()\n        }\n    }\n\n    //TO RENAME IN SET SYNTH PARAMETERS\n    setParameters({\n                      volume = this.synthPreset.vol,\n                      modulation = this.synthPreset.mod,\n                      transpose = this.synthPreset.transpose,\n                      pan = this.synthPreset.pan,\n                      type = this.synthPreset.type,\n                      waveform = this.synthPreset.waveform\n                  }) {\n        if (this.initialized) {\n            this.synthPreset.vol = volume;\n            this.synthPreset.mod = modulation;\n            this.synthPreset.transpose = transpose;\n            this.synthPreset.pan = pan;\n            this.synthPreset.type = type;\n            this.synthPreset.waveform = waveform;\n            //console.log(this.synthPreset.waveform)\n\n            this.updateSynths()\n            this.updateModulators()\n        } else {\n            console.log(\"Polysynth not initialized\")\n        }\n    }\n\n// connect each voice to the new routing\n    connect(route) {\n        this.gainNode.connect(route)\n    }\n\n    disconnectDispose() {\n        //for each voice\n        this.allVoices.forEach(voice => {\n            //Disconnect and dispose synth\n            voice = toRaw(voice)\n            voice.synth.disconnect()\n            voice.synth.dispose()\n            //Disconnect and dispose gain\n            voice.gain.disconnect()\n            voice.gain.dispose()\n            //Disconnect and dispose modulators\n            for (let type in voice.modulators) {\n                for (let target in voice.modulators[type]) {\n                    if (voice.modulators[type][target].signal) {\n                        voice.modulators[type][target].signal.disconnect()\n                        voice.modulators[type][target].signal.dispose()\n                        voice.modulators[type][target].scale.disconnect()\n                        voice.modulators[type][target].scale.dispose()\n                    }\n                }\n            }\n        });\n        //disconnect and dispose main gainNode\n        this.gainNode.disconnect()\n        this.gainNode.dispose()\n\n        //console.log(\"MyPolySynth completely disconnected and disposed\")\n    }\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}