{"ast":null,"code":"import _classCallCheck from \"/Users/eliapirrello/Documents/GitHub/zenyth/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/eliapirrello/Documents/GitHub/zenyth/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"/Users/eliapirrello/Documents/GitHub/zenyth/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/eliapirrello/Documents/GitHub/zenyth/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/eliapirrello/Documents/GitHub/zenyth/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/eliapirrello/Documents/GitHub/zenyth/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.typed-array.float32-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.find-last.js\";\nimport \"core-js/modules/es.typed-array.find-last-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/es.typed-array.from.js\";\nimport \"core-js/modules/es.array.some.js\";\nimport \"core-js/modules/es.array.includes.js\";\nimport \"core-js/modules/es.string.includes.js\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { isArray, isFunction } from \"../core/util/TypeCheck\";\nimport { assert } from \"../core/util/Debug\";\nimport { Signal } from \"./Signal\";\nimport { SignalOperator } from \"./SignalOperator\";\n/**\n * Wraps the native Web Audio API\n * [WaveShaperNode](http://webaudio.github.io/web-audio-api/#the-waveshapernode-interface).\n *\n * @example\n * const osc = new Tone.Oscillator().toDestination().start();\n * // multiply the output of the signal by 2 using the waveshaper's function\n * const timesTwo = new Tone.WaveShaper((val) => val * 2, 2048).connect(osc.frequency);\n * const signal = new Tone.Signal(440).connect(timesTwo);\n * @category Signal\n */\nexport var WaveShaper = /*#__PURE__*/function (_SignalOperator) {\n  _inherits(WaveShaper, _SignalOperator);\n  var _super = _createSuper(WaveShaper);\n  function WaveShaper() {\n    var _this;\n    _classCallCheck(this, WaveShaper);\n    _this = _super.call(this, Object.assign(optionsFromArguments(WaveShaper.getDefaults(), arguments, [\"mapping\", \"length\"])));\n    _this.name = \"WaveShaper\";\n    /**\n     * the waveshaper node\n     */\n    _this._shaper = _this.context.createWaveShaper();\n    /**\n     * The input to the waveshaper node.\n     */\n    _this.input = _this._shaper;\n    /**\n     * The output from the waveshaper node\n     */\n    _this.output = _this._shaper;\n    var options = optionsFromArguments(WaveShaper.getDefaults(), arguments, [\"mapping\", \"length\"]);\n    if (isArray(options.mapping) || options.mapping instanceof Float32Array) {\n      _this.curve = Float32Array.from(options.mapping);\n    } else if (isFunction(options.mapping)) {\n      _this.setMap(options.mapping, options.length);\n    }\n    return _this;\n  }\n  _createClass(WaveShaper, [{\n    key: \"setMap\",\n    value:\n    /**\n     * Uses a mapping function to set the value of the curve.\n     * @param mapping The function used to define the values.\n     *                The mapping function take two arguments:\n     *                the first is the value at the current position\n     *                which goes from -1 to 1 over the number of elements\n     *                in the curve array. The second argument is the array position.\n     * @example\n     * const shaper = new Tone.WaveShaper();\n     * // map the input signal from [-1, 1] to [0, 10]\n     * shaper.setMap((val, index) => (val + 1) * 5);\n     */\n    function setMap(mapping) {\n      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1024;\n      var array = new Float32Array(length);\n      for (var i = 0, len = length; i < len; i++) {\n        var normalized = i / (len - 1) * 2 - 1;\n        array[i] = mapping(normalized, i);\n      }\n      this.curve = array;\n      return this;\n    }\n    /**\n     * The array to set as the waveshaper curve. For linear curves\n     * array length does not make much difference, but for complex curves\n     * longer arrays will provide smoother interpolation.\n     */\n  }, {\n    key: \"curve\",\n    get: function get() {\n      return this._shaper.curve;\n    },\n    set: function set(mapping) {\n      this._shaper.curve = mapping;\n    }\n    /**\n     * Specifies what type of oversampling (if any) should be used when\n     * applying the shaping curve. Can either be \"none\", \"2x\" or \"4x\".\n     */\n  }, {\n    key: \"oversample\",\n    get: function get() {\n      return this._shaper.oversample;\n    },\n    set: function set(oversampling) {\n      var isOverSampleType = [\"none\", \"2x\", \"4x\"].some(function (str) {\n        return str.includes(oversampling);\n      });\n      assert(isOverSampleType, \"oversampling must be either 'none', '2x', or '4x'\");\n      this._shaper.oversample = oversampling;\n    }\n    /**\n     * Clean up.\n     */\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(WaveShaper.prototype), \"dispose\", this).call(this);\n      this._shaper.disconnect();\n      return this;\n    }\n  }], [{\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return Object.assign(Signal.getDefaults(), {\n        length: 1024\n      });\n    }\n  }]);\n  return WaveShaper;\n}(SignalOperator);","map":{"version":3,"mappings":"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","names":["optionsFromArguments","isArray","isFunction","assert","Signal","SignalOperator","WaveShaper","Object","assign","getDefaults","arguments","context","createWaveShaper","_shaper","options","mapping","Float32Array","curve","from","setMap","length","array","i","len","normalized","oversample","oversampling","isOverSampleType","some","str","includes","disconnect"],"sourceRoot":"","sources":["../../../Tone/signal/WaveShaper.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module","externalDependencies":[]}