{"ast":null,"code":"import { dbToGain, gainToDb } from \"../type/Conversions\";\nimport { isAudioParam } from \"../util/AdvancedTypeCheck\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isDefined } from \"../util/TypeCheck\";\nimport { ToneWithContext } from \"./ToneWithContext\";\nimport { EQ } from \"../util/Math\";\nimport { assert, assertRange } from \"../util/Debug\";\n/**\n * Param wraps the native Web Audio's AudioParam to provide\n * additional unit conversion functionality. It also\n * serves as a base-class for classes which have a single,\n * automatable parameter.\n * @category Core\n */\nexport class Param extends ToneWithContext {\n  constructor() {\n    super(optionsFromArguments(Param.getDefaults(), arguments, [\"param\", \"units\", \"convert\"]));\n    this.name = \"Param\";\n    this.overridden = false;\n    /**\n     * The minimum output value\n     */\n    this._minOutput = 1e-7;\n    const options = optionsFromArguments(Param.getDefaults(), arguments, [\"param\", \"units\", \"convert\"]);\n    assert(isDefined(options.param) && (isAudioParam(options.param) || options.param instanceof Param), \"param must be an AudioParam\");\n    while (!isAudioParam(options.param)) {\n      options.param = options.param._param;\n    }\n    this._swappable = isDefined(options.swappable) ? options.swappable : false;\n    if (this._swappable) {\n      this.input = this.context.createGain();\n      // initialize\n      this._param = options.param;\n      this.input.connect(this._param);\n    } else {\n      this._param = this.input = options.param;\n    }\n    this._events = new Timeline(1000);\n    this._initialValue = this._param.defaultValue;\n    this.units = options.units;\n    this.convert = options.convert;\n    this._minValue = options.minValue;\n    this._maxValue = options.maxValue;\n    // if the value is defined, set it immediately\n    if (isDefined(options.value) && options.value !== this._toType(this._initialValue)) {\n      this.setValueAtTime(options.value, 0);\n    }\n  }\n  static getDefaults() {\n    return Object.assign(ToneWithContext.getDefaults(), {\n      convert: true,\n      units: \"number\"\n    });\n  }\n  get value() {\n    const now = this.now();\n    return this.getValueAtTime(now);\n  }\n  set value(value) {\n    this.cancelScheduledValues(this.now());\n    this.setValueAtTime(value, this.now());\n  }\n  get minValue() {\n    // if it's not the default minValue, return it\n    if (isDefined(this._minValue)) {\n      return this._minValue;\n    } else if (this.units === \"time\" || this.units === \"frequency\" || this.units === \"normalRange\" || this.units === \"positive\" || this.units === \"transportTime\" || this.units === \"ticks\" || this.units === \"bpm\" || this.units === \"hertz\" || this.units === \"samples\") {\n      return 0;\n    } else if (this.units === \"audioRange\") {\n      return -1;\n    } else if (this.units === \"decibels\") {\n      return -Infinity;\n    } else {\n      return this._param.minValue;\n    }\n  }\n  get maxValue() {\n    if (isDefined(this._maxValue)) {\n      return this._maxValue;\n    } else if (this.units === \"normalRange\" || this.units === \"audioRange\") {\n      return 1;\n    } else {\n      return this._param.maxValue;\n    }\n  }\n  /**\n   * Type guard based on the unit name\n   */\n  _is(arg, type) {\n    return this.units === type;\n  }\n  /**\n   * Make sure the value is always in the defined range\n   */\n  _assertRange(value) {\n    if (isDefined(this.maxValue) && isDefined(this.minValue)) {\n      assertRange(value, this._fromType(this.minValue), this._fromType(this.maxValue));\n    }\n    return value;\n  }\n  /**\n   * Convert the given value from the type specified by Param.units\n   * into the destination value (such as Gain or Frequency).\n   */\n  _fromType(val) {\n    if (this.convert && !this.overridden) {\n      if (this._is(val, \"time\")) {\n        return this.toSeconds(val);\n      } else if (this._is(val, \"decibels\")) {\n        return dbToGain(val);\n      } else if (this._is(val, \"frequency\")) {\n        return this.toFrequency(val);\n      } else {\n        return val;\n      }\n    } else if (this.overridden) {\n      // if it's overridden, should only schedule 0s\n      return 0;\n    } else {\n      return val;\n    }\n  }\n  /**\n   * Convert the parameters value into the units specified by Param.units.\n   */\n  _toType(val) {\n    if (this.convert && this.units === \"decibels\") {\n      return gainToDb(val);\n    } else {\n      return val;\n    }\n  }\n  //-------------------------------------\n  // ABSTRACT PARAM INTERFACE\n  // all docs are generated from ParamInterface.ts\n  //-------------------------------------\n  setValueAtTime(value, time) {\n    const computedTime = this.toSeconds(time);\n    const numericValue = this._fromType(value);\n    assert(isFinite(numericValue) && isFinite(computedTime), `Invalid argument(s) to setValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(time)}`);\n    this._assertRange(numericValue);\n    this.log(this.units, \"setValueAtTime\", value, computedTime);\n    this._events.add({\n      time: computedTime,\n      type: \"setValueAtTime\",\n      value: numericValue\n    });\n    this._param.setValueAtTime(numericValue, computedTime);\n    return this;\n  }\n  getValueAtTime(time) {\n    const computedTime = Math.max(this.toSeconds(time), 0);\n    const after = this._events.getAfter(computedTime);\n    const before = this._events.get(computedTime);\n    let value = this._initialValue;\n    // if it was set by\n    if (before === null) {\n      value = this._initialValue;\n    } else if (before.type === \"setTargetAtTime\" && (after === null || after.type === \"setValueAtTime\")) {\n      const previous = this._events.getBefore(before.time);\n      let previousVal;\n      if (previous === null) {\n        previousVal = this._initialValue;\n      } else {\n        previousVal = previous.value;\n      }\n      if (before.type === \"setTargetAtTime\") {\n        value = this._exponentialApproach(before.time, previousVal, before.value, before.constant, computedTime);\n      }\n    } else if (after === null) {\n      value = before.value;\n    } else if (after.type === \"linearRampToValueAtTime\" || after.type === \"exponentialRampToValueAtTime\") {\n      let beforeValue = before.value;\n      if (before.type === \"setTargetAtTime\") {\n        const previous = this._events.getBefore(before.time);\n        if (previous === null) {\n          beforeValue = this._initialValue;\n        } else {\n          beforeValue = previous.value;\n        }\n      }\n      if (after.type === \"linearRampToValueAtTime\") {\n        value = this._linearInterpolate(before.time, beforeValue, after.time, after.value, computedTime);\n      } else {\n        value = this._exponentialInterpolate(before.time, beforeValue, after.time, after.value, computedTime);\n      }\n    } else {\n      value = before.value;\n    }\n    return this._toType(value);\n  }\n  setRampPoint(time) {\n    time = this.toSeconds(time);\n    let currentVal = this.getValueAtTime(time);\n    this.cancelAndHoldAtTime(time);\n    if (this._fromType(currentVal) === 0) {\n      currentVal = this._toType(this._minOutput);\n    }\n    this.setValueAtTime(currentVal, time);\n    return this;\n  }\n  linearRampToValueAtTime(value, endTime) {\n    const numericValue = this._fromType(value);\n    const computedTime = this.toSeconds(endTime);\n    assert(isFinite(numericValue) && isFinite(computedTime), `Invalid argument(s) to linearRampToValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(endTime)}`);\n    this._assertRange(numericValue);\n    this._events.add({\n      time: computedTime,\n      type: \"linearRampToValueAtTime\",\n      value: numericValue\n    });\n    this.log(this.units, \"linearRampToValueAtTime\", value, computedTime);\n    this._param.linearRampToValueAtTime(numericValue, computedTime);\n    return this;\n  }\n  exponentialRampToValueAtTime(value, endTime) {\n    let numericValue = this._fromType(value);\n    // the value can't be 0\n    numericValue = EQ(numericValue, 0) ? this._minOutput : numericValue;\n    this._assertRange(numericValue);\n    const computedTime = this.toSeconds(endTime);\n    assert(isFinite(numericValue) && isFinite(computedTime), `Invalid argument(s) to exponentialRampToValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(endTime)}`);\n    // store the event\n    this._events.add({\n      time: computedTime,\n      type: \"exponentialRampToValueAtTime\",\n      value: numericValue\n    });\n    this.log(this.units, \"exponentialRampToValueAtTime\", value, computedTime);\n    this._param.exponentialRampToValueAtTime(numericValue, computedTime);\n    return this;\n  }\n  exponentialRampTo(value, rampTime, startTime) {\n    startTime = this.toSeconds(startTime);\n    this.setRampPoint(startTime);\n    this.exponentialRampToValueAtTime(value, startTime + this.toSeconds(rampTime));\n    return this;\n  }\n  linearRampTo(value, rampTime, startTime) {\n    startTime = this.toSeconds(startTime);\n    this.setRampPoint(startTime);\n    this.linearRampToValueAtTime(value, startTime + this.toSeconds(rampTime));\n    return this;\n  }\n  targetRampTo(value, rampTime, startTime) {\n    startTime = this.toSeconds(startTime);\n    this.setRampPoint(startTime);\n    this.exponentialApproachValueAtTime(value, startTime, rampTime);\n    return this;\n  }\n  exponentialApproachValueAtTime(value, time, rampTime) {\n    time = this.toSeconds(time);\n    rampTime = this.toSeconds(rampTime);\n    const timeConstant = Math.log(rampTime + 1) / Math.log(200);\n    this.setTargetAtTime(value, time, timeConstant);\n    // at 90% start a linear ramp to the final value\n    this.cancelAndHoldAtTime(time + rampTime * 0.9);\n    this.linearRampToValueAtTime(value, time + rampTime);\n    return this;\n  }\n  setTargetAtTime(value, startTime, timeConstant) {\n    const numericValue = this._fromType(value);\n    // The value will never be able to approach without timeConstant > 0.\n    assert(isFinite(timeConstant) && timeConstant > 0, \"timeConstant must be a number greater than 0\");\n    const computedTime = this.toSeconds(startTime);\n    this._assertRange(numericValue);\n    assert(isFinite(numericValue) && isFinite(computedTime), `Invalid argument(s) to setTargetAtTime: ${JSON.stringify(value)}, ${JSON.stringify(startTime)}`);\n    this._events.add({\n      constant: timeConstant,\n      time: computedTime,\n      type: \"setTargetAtTime\",\n      value: numericValue\n    });\n    this.log(this.units, \"setTargetAtTime\", value, computedTime, timeConstant);\n    this._param.setTargetAtTime(numericValue, computedTime, timeConstant);\n    return this;\n  }\n  setValueCurveAtTime(values, startTime, duration, scaling = 1) {\n    duration = this.toSeconds(duration);\n    startTime = this.toSeconds(startTime);\n    const startingValue = this._fromType(values[0]) * scaling;\n    this.setValueAtTime(this._toType(startingValue), startTime);\n    const segTime = duration / (values.length - 1);\n    for (let i = 1; i < values.length; i++) {\n      const numericValue = this._fromType(values[i]) * scaling;\n      this.linearRampToValueAtTime(this._toType(numericValue), startTime + i * segTime);\n    }\n    return this;\n  }\n  cancelScheduledValues(time) {\n    const computedTime = this.toSeconds(time);\n    assert(isFinite(computedTime), `Invalid argument to cancelScheduledValues: ${JSON.stringify(time)}`);\n    this._events.cancel(computedTime);\n    this._param.cancelScheduledValues(computedTime);\n    this.log(this.units, \"cancelScheduledValues\", computedTime);\n    return this;\n  }\n  cancelAndHoldAtTime(time) {\n    const computedTime = this.toSeconds(time);\n    const valueAtTime = this._fromType(this.getValueAtTime(computedTime));\n    // remove the schedule events\n    assert(isFinite(computedTime), `Invalid argument to cancelAndHoldAtTime: ${JSON.stringify(time)}`);\n    this.log(this.units, \"cancelAndHoldAtTime\", computedTime, \"value=\" + valueAtTime);\n    // if there is an event at the given computedTime\n    // and that even is not a \"set\"\n    const before = this._events.get(computedTime);\n    const after = this._events.getAfter(computedTime);\n    if (before && EQ(before.time, computedTime)) {\n      // remove everything after\n      if (after) {\n        this._param.cancelScheduledValues(after.time);\n        this._events.cancel(after.time);\n      } else {\n        this._param.cancelAndHoldAtTime(computedTime);\n        this._events.cancel(computedTime + this.sampleTime);\n      }\n    } else if (after) {\n      this._param.cancelScheduledValues(after.time);\n      // cancel the next event(s)\n      this._events.cancel(after.time);\n      if (after.type === \"linearRampToValueAtTime\") {\n        this.linearRampToValueAtTime(this._toType(valueAtTime), computedTime);\n      } else if (after.type === \"exponentialRampToValueAtTime\") {\n        this.exponentialRampToValueAtTime(this._toType(valueAtTime), computedTime);\n      }\n    }\n    // set the value at the given time\n    this._events.add({\n      time: computedTime,\n      type: \"setValueAtTime\",\n      value: valueAtTime\n    });\n    this._param.setValueAtTime(valueAtTime, computedTime);\n    return this;\n  }\n  rampTo(value, rampTime = 0.1, startTime) {\n    if (this.units === \"frequency\" || this.units === \"bpm\" || this.units === \"decibels\") {\n      this.exponentialRampTo(value, rampTime, startTime);\n    } else {\n      this.linearRampTo(value, rampTime, startTime);\n    }\n    return this;\n  }\n  /**\n   * Apply all of the previously scheduled events to the passed in Param or AudioParam.\n   * The applied values will start at the context's current time and schedule\n   * all of the events which are scheduled on this Param onto the passed in param.\n   */\n  apply(param) {\n    const now = this.context.currentTime;\n    // set the param's value at the current time and schedule everything else\n    param.setValueAtTime(this.getValueAtTime(now), now);\n    // if the previous event was a curve, then set the rest of it\n    const previousEvent = this._events.get(now);\n    if (previousEvent && previousEvent.type === \"setTargetAtTime\") {\n      // approx it until the next event with linear ramps\n      const nextEvent = this._events.getAfter(previousEvent.time);\n      // or for 2 seconds if there is no event\n      const endTime = nextEvent ? nextEvent.time : now + 2;\n      const subdivisions = (endTime - now) / 10;\n      for (let i = now; i < endTime; i += subdivisions) {\n        param.linearRampToValueAtTime(this.getValueAtTime(i), i);\n      }\n    }\n    this._events.forEachAfter(this.context.currentTime, event => {\n      if (event.type === \"cancelScheduledValues\") {\n        param.cancelScheduledValues(event.time);\n      } else if (event.type === \"setTargetAtTime\") {\n        param.setTargetAtTime(event.value, event.time, event.constant);\n      } else {\n        param[event.type](event.value, event.time);\n      }\n    });\n    return this;\n  }\n  /**\n   * Replace the Param's internal AudioParam. Will apply scheduled curves\n   * onto the parameter and replace the connections.\n   */\n  setParam(param) {\n    assert(this._swappable, \"The Param must be assigned as 'swappable' in the constructor\");\n    const input = this.input;\n    input.disconnect(this._param);\n    this.apply(param);\n    this._param = param;\n    input.connect(this._param);\n    return this;\n  }\n  dispose() {\n    super.dispose();\n    this._events.dispose();\n    return this;\n  }\n  get defaultValue() {\n    return this._toType(this._param.defaultValue);\n  }\n  //-------------------------------------\n  // \tAUTOMATION CURVE CALCULATIONS\n  // \tMIT License, copyright (c) 2014 Jordan Santell\n  //-------------------------------------\n  // Calculates the the value along the curve produced by setTargetAtTime\n  _exponentialApproach(t0, v0, v1, timeConstant, t) {\n    return v1 + (v0 - v1) * Math.exp(-(t - t0) / timeConstant);\n  }\n  // Calculates the the value along the curve produced by linearRampToValueAtTime\n  _linearInterpolate(t0, v0, t1, v1, t) {\n    return v0 + (v1 - v0) * ((t - t0) / (t1 - t0));\n  }\n  // Calculates the the value along the curve produced by exponentialRampToValueAtTime\n  _exponentialInterpolate(t0, v0, t1, v1, t) {\n    return v0 * Math.pow(v1 / v0, (t - t0) / (t1 - t0));\n  }\n}","map":{"version":3,"mappings":"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","names":["dbToGain","gainToDb","isAudioParam","optionsFromArguments","Timeline","isDefined","ToneWithContext","EQ","assert","assertRange","Param","constructor","getDefaults","arguments","options","param","_param","_swappable","swappable","input","context","createGain","connect","_events","_initialValue","defaultValue","units","convert","_minValue","minValue","_maxValue","maxValue","value","_toType","setValueAtTime","Object","assign","now","getValueAtTime","cancelScheduledValues","Infinity","_is","arg","type","_assertRange","_fromType","val","overridden","toSeconds","toFrequency","time","computedTime","numericValue","isFinite","JSON","stringify","log","add","Math","max","after","getAfter","before","get","previous","getBefore","previousVal","_exponentialApproach","constant","beforeValue","_linearInterpolate","_exponentialInterpolate","setRampPoint","currentVal","cancelAndHoldAtTime","_minOutput","linearRampToValueAtTime","endTime","exponentialRampToValueAtTime","exponentialRampTo","rampTime","startTime","linearRampTo","targetRampTo","exponentialApproachValueAtTime","timeConstant","setTargetAtTime","setValueCurveAtTime","values","duration","scaling","startingValue","segTime","length","i","cancel","valueAtTime","sampleTime","rampTo","apply","currentTime","previousEvent","nextEvent","subdivisions","forEachAfter","event","setParam","disconnect","dispose","t0","v0","v1","t","exp","t1","pow"],"sourceRoot":"","sources":["../../../../Tone/core/context/Param.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module","externalDependencies":[]}