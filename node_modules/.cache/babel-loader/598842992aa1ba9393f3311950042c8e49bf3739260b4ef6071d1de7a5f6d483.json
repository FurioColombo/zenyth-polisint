{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Synth, Envelope, Gain, Meter, Frequency, LFO } from 'tone';\nimport { nextTick } from 'vue';\nimport * as Tone from 'tone';\nimport { isProxy, toRaw } from 'vue';\nconst max_partials_num = 50;\nconst vol_damp_factor = 0.5;\nexport default class MyPolySynth {\n  constructor(synthType = \"\", destination = null, nVoices = 16) {\n    this.destination = destination;\n\n    //data of all modulators that could potentially be linked to the parameters of the synth\n    this.modulatorsData = {\n      envelope: {\n        vol: {\n          amount: 1,\n          parameters: {\n            attack: 1,\n            decay: 0.3,\n            sustain: 0.8,\n            release: 1\n          }\n        },\n        mod: {\n          amount: 0,\n          parameters: {\n            attack: 0.05,\n            decay: 0.1,\n            sustain: 1,\n            release: 0.2\n          }\n        },\n        pitch: {\n          amount: 0,\n          parameters: {\n            attack: 0.05,\n            decay: 0.1,\n            sustain: 1,\n            release: 0.2\n          }\n        }\n      },\n      lfo: {\n        vol: {\n          amount: 0,\n          parameters: {\n            frequency: 10,\n            waveform: \"sine\",\n            min: 0,\n            max: 1\n          }\n        },\n        mod: {\n          amount: 0,\n          parameters: {\n            frequency: 10,\n            waveform: \"sine\",\n            min: 0,\n            max: 1\n          }\n        },\n        pitch: {\n          amount: 0,\n          parameters: {\n            frequency: 10,\n            waveform: \"sine\",\n            min: 0,\n            max: 1\n          }\n        }\n      }\n    };\n\n    //preset with which all voices of polyphony will be created\n    this.synthPreset = {\n      type: synthType,\n      waveform: \"sine\",\n      vol: -12,\n      transpose: 0,\n      mod: 0,\n      partials: \"\",\n      pan: \"\"\n    };\n\n    //modulation effect\n    //this.crusher = new Tone.BitCrusher(3)\n\n    this.dampNode = new Gain(vol_damp_factor);\n    //all polyphony voices are connected here\n\n    //console.log(Tone.dbToGain(this.synthPreset.vol))\n    this.gainNode = new Gain(1);\n\n    //list of polyphony voices\n    this.allVoices = []; //always holds reference to all voices\n    this.freeVoices = []; //holds reference to free voices\n    this.busyVoices = {}; //holds reference to busy voices, key=note, value=voice\n    this.nVoices = nVoices; //used to initialize, taken from globalProperties\n    this.lastNotes = Array(this.nVoices); //stores last nVoices played\n\n    //INIT VOICES\n    this.initVoices();\n\n    // connect gainNode to destination\n    this.gainNode.connect(this.dampNode);\n    //this.crusher.connect(this.dampNode)\n    this.dampNode.connect(this.destination);\n  }\n  initVoices() {\n    //for each voice\n\n    for (let index = 0; index < this.nVoices; index++) {\n      //initializing empty modulators matrix\n      let modulators = {\n        envelope: {\n          vol: {\n            amount: 1,\n            signal: null,\n            scale: null\n          },\n          mod: {\n            amount: 0,\n            signal: null,\n            scale: null\n          },\n          pitch: {\n            amount: 0,\n            signal: null,\n            scale: null\n          }\n        },\n        lfo: {\n          vol: {\n            amount: 0,\n            signal: null,\n            scale: null\n          },\n          mod: {\n            amount: 0,\n            signal: null,\n            scale: null\n          },\n          pitch: {\n            amount: 0,\n            signal: null,\n            scale: null\n          }\n        }\n      };\n      let lfoGain = new Gain();\n      lfoGain.connect(this.gainNode); //USED TO CONNECT LFO TO VOICE VOLUME\n\n      //creating gain and synth\n      let gain = new Gain(1).connect(lfoGain);\n      //synth is created and initialized with preset parameters\n      let synth = this.createSynth();\n      synth.oscillator.disconnect();\n      synth.oscillator.connect(gain);\n\n      //disconnect and dispose synth inner envelope\n      synth.envelope.disconnect();\n      synth.envelope.dispose();\n\n      //thanks to noiseAdsrGain we can lower to zero the volume of the synth and still hear the noise, bypassing the synth volume\n      let noiseAdsrGain = new Gain(); //used to have the same main adsr of synth on the noise too\n      let noiseGain = new Gain();\n      let noise = new Tone.Noise(\"pink\");\n      noise.connect(noiseGain);\n      noiseGain.connect(noiseAdsrGain);\n      noiseAdsrGain.connect(this.dampNode);\n      let voice = {\n        synth: synth,\n        gain: gain,\n        lfoGain: lfoGain,\n        modulators: modulators,\n        noise: noise,\n        noiseGain: noiseGain,\n        noiseAdsrGain: noiseAdsrGain\n      };\n\n      //creating and connecting every modulator\n      for (let type in modulators) {\n        for (let target in modulators[type]) {\n          let tempMod = this.createModulator(type);\n          modulators[type][target].signal = tempMod;\n          modulators[type][target].scale = this.createScale(target);\n          this.connectModulator(modulators[type][target], type, target, voice);\n        }\n      }\n      //pushing voice into freeVoices array\n      this.freeVoices.push(voice);\n      this.allVoices.push(voice);\n    }\n    this.initialized = false;\n    //setting all parameters of modulators\n    this.updateModulators();\n    this.initialized = true;\n  }\n  playNote(note, velocity) {\n    //console.log(this.freeVoices)\n    if (this.initialized) {\n      this.lastNotes.push(note);\n      if (this.lastNotes.length > this.nVoices) {\n        this.lastNote = this.lastNotes.shift();\n      }\n\n      //removing first free voice from array\n      let voice = this.freeVoices.shift();\n      if (!voice) {\n        //console.log(\"NEW NOTE OVERWRITE: \" + this.lastNote)\n        voice = this.busyVoices[this.lastNote];\n        delete this.busyVoices[this.lastNote];\n      }\n      this.busyVoices[note] = voice;\n\n      //trigger attack in each modulator\n      for (let type in voice.modulators) {\n        for (let target in voice.modulators[type]) {\n          if (voice.modulators[type][target].amount > 0) {\n            switch (type) {\n              case \"envelope\":\n                //console.log(\"TRIGGERING ATTACK IN \"+type+\" connected to \"+target)\n                //console.log(voice.modulators[type][target].signal)\n                toRaw(voice.modulators[type][target].signal).cancel(Tone.now());\n                toRaw(voice.modulators[type][target].signal).triggerAttack(Tone.now());\n                break;\n              case \"lfo\":\n                toRaw(voice.modulators[type][target]).signal.stop();\n                toRaw(voice.modulators[type][target]).signal.start();\n                break;\n              default:\n                break;\n            }\n          }\n        }\n      }\n      voice.synth.oscillator.stop(Tone.now());\n      voice.synth.envelope.cancel(Tone.now());\n      //trigger attack in synth and noise\n      voice.noise.start();\n      voice.synth.triggerAttack(note, Tone.now(), velocity / 128);\n    }\n  }\n  stopNote(note) {\n    if (this.initialized) {\n      if (this.busyVoices[note]) {\n        let voice = this.busyVoices[note];\n        delete this.busyVoices[note];\n        this.freeVoices.push(voice);\n\n        //triggerRelease on all envelopes\n        for (let type in voice.modulators) {\n          for (let target in voice.modulators[type]) {\n            if (voice.modulators[type][target].signal) {\n              switch (type) {\n                case \"envelope\":\n                  //console.log(\"Triggering release of \"+type+\" with target \"+target)\n                  voice.modulators[type][target].signal.triggerRelease(Tone.now());\n                  break;\n                case \"lfo\":\n                  //lfos are never stopped, just diminished in amount if needed\n                  //fvoice.modulators[type][target].signal.stop()\n                  break;\n                default:\n                  break;\n              }\n            }\n          }\n        }\n        setTimeout(() => {\n          voice.synth.triggerRelease(Tone.now());\n          voice.noise.stop();\n        }, this.modulatorsData.envelope.vol.parameters.release * 1000);\n      }\n    }\n  }\n  createSynth() {\n    let synth = new Synth();\n    //Setting parameters\n    nextTick(() => {\n      synth.set({\n        \"volume\": this.synthPreset.vol,\n        \"detune\": this.synthPreset.transpose * 100,\n        \"oscillator\": {\n          \"type\": this.synthPreset.type + this.synthPreset.waveform + this.synthPreset.partials\n        }\n      });\n    });\n    //console.log(this.synthPreset.type + this.synthPreset.waveform + this.synthPreset.partials)\n\n    return synth;\n  }\n  createModulator(type) {\n    //console.log(\"creating modulator of type: \"+type)\n    switch (type) {\n      case \"envelope\":\n        return new Envelope();\n      case \"lfo\":\n        return new LFO();\n      default:\n        console.log(\"Error creating modulator\");\n        return null;\n    }\n  }\n  createScale(target) {\n    switch (target) {\n      case \"vol\":\n        return new Tone.Scale(0, 1);\n      case \"mod\":\n        return new Tone.Scale(0, 1);\n      case \"pitch\":\n        return new Tone.Scale(0, 1);\n      case \"pan\":\n        return new Tone.Scale(0, 1);\n      default:\n        console.log(\"Error creating scale for target \" + target);\n        return null;\n    }\n  }\n  updateModulators() {\n    this.allVoices.forEach(voice => {\n      for (let type in voice.modulators) {\n        for (let target in voice.modulators[type]) {\n          //update amount from preset\n          voice.modulators[type][target].amount = this.modulatorsData[type][target].amount;\n          if (!toRaw(voice.modulators[type][target].signal)) {\n            //IF IT'S STILL NOT CREATED\n            //console.log(\"RECREATING\")\n            voice.modulators[type][target].signal = this.createModulator(type);\n            voice.modulators[type][target].scale = this.createScale(target);\n            this.connectModulator(toRaw(voice.modulators[type][target]), type, target, toRaw(voice));\n            //console.log(voice.modulators[type][target])\n          }\n\n          this.scaleSetter(voice.modulators[type][target], target);\n          this.modulatorSetter(toRaw(voice.modulators[type][target].signal), type, this.modulatorsData[type][target].parameters);\n        }\n      }\n    });\n  }\n  updateSynths() {\n    this.allVoices.forEach(voice => {\n      voice.synth.set({\n        \"detune\": this.synthPreset.transpose * 100,\n        \"oscillator\": {\n          \"type\": this.synthPreset.type + this.synthPreset.waveform + this.synthPreset.partials\n        }\n      });\n      //this.gainNode.set({gain: Tone.dbToGain(this.synthPreset.vol)})\n      voice.noiseGain.set({\n        gain: this.synthPreset.mod\n      });\n    });\n  }\n  scaleSetter(modulator, target) {\n    switch (target) {\n      case \"vol\":\n        //ENVELOPE FOR VOL SHOULD HAVE SCALE TOO TO CENTER AROUND SELECTED FREQUENCY\n        toRaw(modulator.scale).set({\n          min: Math.max(Tone.dbToGain(this.synthPreset.vol) - modulator.amount, 0),\n          max: Math.min(Tone.dbToGain(this.synthPreset.vol) + modulator.amount, 1)\n        });\n        break;\n      case \"mod\":\n        toRaw(modulator.scale).set({\n          min: Math.max(this.synthPreset.mod - modulator.amount, 0),\n          max: Math.min(this.synthPreset.mod + modulator.amount, 1)\n        });\n        break;\n      case \"pitch\":\n        //TO-DO\n        //console.log(\"CHANGING SCALE \")\n        //console.log(modulator.scale)\n        toRaw(modulator.scale).set({\n          min: (this.synthPreset.transpose - 24 * modulator.amount) * 100,\n          max: (this.synthPreset.transpose + 24 * modulator.amount) * 100\n        });\n        break;\n      case \"pan\":\n        //TO-DO\n        break;\n      default:\n        console.log(\"invalid target to connect modulator to\");\n        break;\n    }\n  }\n  modulatorSetter(modulator, type, parameters) {\n    // console.log(\"mypolysynth - modulator setter - parameters: \", toRaw(parameters).waveform)\n    if (!toRaw(parameters).waveform) toRaw(parameters).waveform = modulator.type;\n    switch (type) {\n      case \"envelope\":\n        modulator.set({\n          \"attack\": parameters.attack,\n          \"decay\": parameters.decay,\n          \"sustain\": parameters.sustain,\n          \"release\": parameters.release + 0.001\n        });\n        //console.log(\"JUST SET PARAMETERS OF\")\n        //console.log(modulator)\n        //console.log(\"WITH\")\n        //console.log(parameters)\n        break;\n      case \"lfo\":\n        //TO-DO\n        //console.log(\"PARAMETERS\")\n        //console.log(parameters)\n        modulator.set({\n          //\n          \"type\": toRaw(parameters).waveform,\n          \"frequency\": toRaw(parameters).frequency\n        });\n        break;\n      default:\n        console.log(\"Error setting modulator parameters, invalid args\");\n        break;\n    }\n    // console.log(\"modulator.type: \", modulator.type)\n  }\n\n  //have to pass, the modulator (tone), the type (lfo or envelope), the gain linked to the voice, the voice and the target\n  connectModulator(modulator, type, target, voice) {\n    //console.log(\"connecting\")\n    //console.log(modulator)\n    //console.log(\"to voice: \")\n    //console.log(voice)\n    //console.log(\"to target: \" + target)\n    switch (type) {\n      case \"envelope\":\n        switch (target) {\n          case \"vol\":\n            modulator.signal.chain(modulator.scale, voice.gain.gain);\n            //modulator.signal.connect(voice.gain.gain)   //SET MAIN ADSR TO SYNTH GAIN\n            modulator.signal.connect(voice.noiseAdsrGain.gain); //SET MAIN ADSR TO NOISE GAIN\n            break;\n          case \"mod\":\n            modulator.signal.chain(modulator.scale, voice.noiseGain.gain);\n            break;\n          case \"pitch\":\n            //TO-DO\n            this.scaleSetter(modulator, target);\n            modulator.signal.chain(modulator.scale, voice.synth.detune);\n            break;\n          case \"pan\":\n            //TO-DO\n            break;\n          default:\n            console.log(\"invalid target to connect modulator to\");\n            break;\n        }\n        break;\n      case \"lfo\":\n        switch (target) {\n          case \"vol\":\n            this.scaleSetter(modulator, target);\n            modulator.signal.chain(modulator.scale, voice.lfoGain.gain);\n            break;\n          case \"mod\":\n            modulator.signal.chain(modulator.scale, voice.noiseGain.gain);\n            break;\n          case \"pitch\":\n            //TO-DO\n            this.scaleSetter(modulator, target);\n            modulator.signal.chain(modulator.scale, voice.synth.detune);\n            break;\n          case \"pan\":\n            //TO-DO\n            break;\n          default:\n            console.log(\"invalid target to connect modulator to\");\n            break;\n        }\n        break;\n      default:\n        console.log(\"invalid modulator type\");\n        break;\n    }\n  }\n\n  // setters\n  setModulatorParameters(type, target, parameters) {\n    //console.log(\"myPolysynth - setModulatorParameters\")\n    if (this.initialized) {\n      this.modulatorsData[type][target].parameters = parameters;\n      // console.log(\"New modulatorsData for type \"+type+\" to target \"+target)\n      // console.log(this.modulatorsData);\n      // console.log(\"params: \" , this.modulatorsData[type][target].parameters,  parameters)\n\n      this.updateModulators();\n      //console.log(\"SETTING\")\n      //console.log(this.modulatorsData)\n    }\n  }\n\n  setModulatorAmount(type, target, amount) {\n    if (this.initialized) {\n      this.modulatorsData[type][target].amount = amount;\n      //console.log(\"setting modulator amount\")\n      this.updateModulators();\n    }\n  }\n\n  //TO RENAME IN SET SYNTH PARAMETERS\n  setParameters({\n    volume = this.synthPreset.vol,\n    modulation = this.synthPreset.mod,\n    transpose = this.synthPreset.transpose,\n    pan = this.synthPreset.pan,\n    type = this.synthPreset.type,\n    waveform = this.synthPreset.waveform\n  }) {\n    if (this.initialized) {\n      this.synthPreset.vol = volume;\n      this.synthPreset.mod = modulation;\n      this.synthPreset.transpose = transpose;\n      this.synthPreset.pan = pan;\n      this.synthPreset.type = type;\n      this.synthPreset.waveform = waveform;\n      //console.log(this.synthPreset.waveform)\n\n      this.updateSynths();\n      this.updateModulators();\n    } else {\n      console.log(\"Polysynth not initialized\");\n    }\n  }\n\n  // connect each voice to the new routing\n  connect(route) {\n    this.gainNode.connect(route);\n  }\n  disconnectDispose() {\n    //for each voice\n    this.allVoices.forEach(voice => {\n      //Disconnect and dispose synth\n      voice = toRaw(voice);\n      voice.synth.disconnect();\n      voice.synth.dispose();\n      //Disconnect and dispose gain\n      voice.gain.disconnect();\n      voice.gain.dispose();\n      //Disconnect and dispose modulators\n      for (let type in voice.modulators) {\n        for (let target in voice.modulators[type]) {\n          if (voice.modulators[type][target].signal) {\n            voice.modulators[type][target].signal.disconnect();\n            voice.modulators[type][target].signal.dispose();\n            voice.modulators[type][target].scale.disconnect();\n            voice.modulators[type][target].scale.dispose();\n          }\n        }\n      }\n    });\n    //disconnect and dispose main gainNode\n    this.gainNode.disconnect();\n    this.gainNode.dispose();\n\n    //console.log(\"MyPolySynth completely disconnected and disposed\")\n  }\n}","map":{"version":3,"names":["Synth","Envelope","Gain","Meter","Frequency","LFO","nextTick","Tone","isProxy","toRaw","max_partials_num","vol_damp_factor","MyPolySynth","constructor","synthType","destination","nVoices","modulatorsData","envelope","vol","amount","parameters","attack","decay","sustain","release","mod","pitch","lfo","frequency","waveform","min","max","synthPreset","type","transpose","partials","pan","dampNode","gainNode","allVoices","freeVoices","busyVoices","lastNotes","Array","initVoices","connect","index","modulators","signal","scale","lfoGain","gain","synth","createSynth","oscillator","disconnect","dispose","noiseAdsrGain","noiseGain","noise","Noise","voice","target","tempMod","createModulator","createScale","connectModulator","push","initialized","updateModulators","playNote","note","velocity","length","lastNote","shift","cancel","now","triggerAttack","stop","start","stopNote","triggerRelease","setTimeout","set","console","log","Scale","forEach","scaleSetter","modulatorSetter","updateSynths","modulator","Math","dbToGain","chain","detune","setModulatorParameters","setModulatorAmount","setParameters","volume","modulation","route","disconnectDispose"],"sources":["/Users/guglielmofratticioli/Documents/POLIMI/FurioColombo.github.io/src/views/Synth/Oscillators/MyPolySynth.js"],"sourcesContent":["import {Synth, Envelope, Gain, Meter, Frequency, LFO} from 'tone'\nimport {nextTick} from 'vue';\nimport * as Tone from 'tone'\nimport {isProxy, toRaw} from 'vue';\n\nconst max_partials_num = 50;\nconst vol_damp_factor = 0.5;\n\nexport default class MyPolySynth {\n    constructor(synthType = \"\", destination = null, nVoices = 16) {\n\n        this.destination = destination;\n\n\n        //data of all modulators that could potentially be linked to the parameters of the synth\n        this.modulatorsData = {\n            envelope: {\n                vol: {\n                    amount: 1,\n                    parameters: {\n                        attack: 1,\n                        decay: 0.3,\n                        sustain: 0.8,\n                        release: 1\n                    }\n                },\n                mod: {\n                    amount: 0,\n                    parameters: {\n                        attack: 0.05,\n                        decay: 0.1,\n                        sustain: 1,\n                        release: 0.2\n                    }\n                },\n                pitch: {\n                    amount: 0,\n                    parameters: {\n                        attack: 0.05,\n                        decay: 0.1,\n                        sustain: 1,\n                        release: 0.2\n                    }\n                },\n            },\n            lfo: {\n                vol: {\n                    amount: 0,\n                    parameters: {\n                        frequency: 10,\n                        waveform: \"sine\",\n                        min: 0,\n                        max: 1\n                    }\n                },\n                mod: {\n                    amount: 0,\n                    parameters: {\n                        frequency: 10,\n                        waveform: \"sine\",\n                        min: 0,\n                        max: 1\n                    }\n                },\n                pitch: {\n                    amount: 0,\n                    parameters: {\n                        frequency: 10,\n                        waveform: \"sine\",\n                        min: 0,\n                        max: 1\n                    }\n                },\n            }\n        }\n\n        //preset with which all voices of polyphony will be created\n        this.synthPreset = {\n            type: synthType,\n            waveform: \"sine\",\n            vol: -12,\n            transpose: 0,\n            mod: 0,\n            partials: \"\",\n            pan: \"\"\n        }\n\n\n        //modulation effect\n        //this.crusher = new Tone.BitCrusher(3)\n\n\n        this.dampNode = new Gain(vol_damp_factor);\n        //all polyphony voices are connected here\n\n        //console.log(Tone.dbToGain(this.synthPreset.vol))\n        this.gainNode = new Gain(1);\n\n        //list of polyphony voices\n        this.allVoices = [] //always holds reference to all voices\n        this.freeVoices = []    //holds reference to free voices\n        this.busyVoices = {}    //holds reference to busy voices, key=note, value=voice\n        this.nVoices = nVoices  //used to initialize, taken from globalProperties\n        this.lastNotes = Array(this.nVoices)  //stores last nVoices played\n\n        //INIT VOICES\n        this.initVoices()\n\n\n        // connect gainNode to destination\n            this.gainNode.connect(this.dampNode)\n            //this.crusher.connect(this.dampNode)\n            this.dampNode.connect(this.destination)\n    }\n\n    initVoices() {\n        //for each voice\n\n        for (let index = 0; index < this.nVoices; index++) {\n\n            //initializing empty modulators matrix\n            let modulators = {\n                envelope: {\n                    vol: {amount: 1, signal: null, scale: null},\n                    mod: {amount: 0, signal: null, scale: null},\n                    pitch: {amount: 0, signal: null, scale: null},\n                },\n                lfo: {\n                    vol: {amount: 0, signal: null, scale: null},\n                    mod: {amount: 0, signal: null, scale: null},\n                    pitch: {amount: 0, signal: null, scale: null},\n                }\n            }\n\n            let lfoGain = new Gain()\n            lfoGain.connect(this.gainNode) //USED TO CONNECT LFO TO VOICE VOLUME\n\n\n            //creating gain and synth\n            let gain = new Gain(1).connect(lfoGain)\n            //synth is created and initialized with preset parameters\n            let synth = this.createSynth()\n            synth.oscillator.disconnect()\n            synth.oscillator.connect(gain)\n\n            //disconnect and dispose synth inner envelope\n            synth.envelope.disconnect()\n            synth.envelope.dispose()\n\n            //thanks to noiseAdsrGain we can lower to zero the volume of the synth and still hear the noise, bypassing the synth volume\n            let noiseAdsrGain = new Gain()  //used to have the same main adsr of synth on the noise too\n            let noiseGain = new Gain()\n            let noise = new Tone.Noise(\"pink\")\n            noise.connect(noiseGain)\n            noiseGain.connect(noiseAdsrGain)\n            noiseAdsrGain.connect(this.dampNode)\n\n\n\n\n            let voice = {synth: synth, gain: gain, lfoGain: lfoGain, modulators: modulators, noise: noise, noiseGain: noiseGain, noiseAdsrGain: noiseAdsrGain}\n\n            //creating and connecting every modulator\n            for (let type in modulators) {\n                for (let target in modulators[type]) {\n                    let tempMod = this.createModulator(type)\n                    modulators[type][target].signal = tempMod\n                    modulators[type][target].scale = this.createScale(target)\n                    this.connectModulator(modulators[type][target], type, target, voice)\n                }\n            }\n            //pushing voice into freeVoices array\n            this.freeVoices.push(voice)\n            this.allVoices.push(voice)\n        }\n\n        this.initialized = false\n        //setting all parameters of modulators\n        this.updateModulators();\n        this.initialized = true\n\n    }\n\n    playNote(note, velocity) {\n        //console.log(this.freeVoices)\n        if (this.initialized) {\n\n            this.lastNotes.push(note);\n            if (this.lastNotes.length > this.nVoices) {\n                this.lastNote = this.lastNotes.shift();\n            }\n\n            //removing first free voice from array\n            let voice = this.freeVoices.shift()\n            if (!voice) {\n                //console.log(\"NEW NOTE OVERWRITE: \" + this.lastNote)\n                voice = this.busyVoices[this.lastNote]\n                delete this.busyVoices[this.lastNote]\n            }\n            this.busyVoices[note] = voice\n\n            //trigger attack in each modulator\n            for (let type in voice.modulators) {\n                for (let target in voice.modulators[type]) {\n                    if (voice.modulators[type][target].amount>0 ) {\n                    switch (type) {\n                        case \"envelope\":\n                            //console.log(\"TRIGGERING ATTACK IN \"+type+\" connected to \"+target)\n                            //console.log(voice.modulators[type][target].signal)\n                            toRaw(voice.modulators[type][target].signal).cancel(Tone.now())\n                            toRaw(voice.modulators[type][target].signal).triggerAttack(Tone.now())\n                            break;\n                        case \"lfo\":\n                            toRaw(voice.modulators[type][target]).signal.stop()\n                            toRaw(voice.modulators[type][target]).signal.start()\n                            break;\n                        default:\n                            break;\n                    }\n                    }\n                }\n            }\n            voice.synth.oscillator.stop(Tone.now())\n            voice.synth.envelope.cancel(Tone.now())\n            //trigger attack in synth and noise\n            voice.noise.start()\n            voice.synth.triggerAttack(note, Tone.now(), velocity / 128)\n        }\n    }\n\n    stopNote(note) {\n        if (this.initialized) {\n            if (this.busyVoices[note]) {\n                let voice = this.busyVoices[note]\n                delete this.busyVoices[note]\n                this.freeVoices.push(voice)\n\n                //triggerRelease on all envelopes\n                for (let type in voice.modulators) {\n                    for (let target in voice.modulators[type]) {\n                        if (voice.modulators[type][target].signal) {\n                            switch (type) {\n                                case \"envelope\":\n                                    //console.log(\"Triggering release of \"+type+\" with target \"+target)\n                                    voice.modulators[type][target].signal.triggerRelease(Tone.now())\n                                    break;\n                                case \"lfo\":\n                                    //lfos are never stopped, just diminished in amount if needed\n                                    //fvoice.modulators[type][target].signal.stop()\n                                    break;\n                                default:\n                                    break;\n                            }\n                        }\n                    }\n                }\n                setTimeout(() => {\n                    voice.synth.triggerRelease(Tone.now())\n                    voice.noise.stop()\n                }, this.modulatorsData.envelope.vol.parameters.release * 1000)\n            }\n        }\n    }\n\n    createSynth() {\n        let synth = new Synth()\n        //Setting parameters\n        nextTick(() => {\n            synth.set({\n                \"volume\": this.synthPreset.vol,\n                \"detune\": this.synthPreset.transpose * 100,\n                \"oscillator\": {\n                    \"type\": this.synthPreset.type + this.synthPreset.waveform + this.synthPreset.partials\n                }\n            })\n        })\n        //console.log(this.synthPreset.type + this.synthPreset.waveform + this.synthPreset.partials)\n\n        return synth\n    }\n\n    createModulator(type) {\n        //console.log(\"creating modulator of type: \"+type)\n        switch (type) {\n            case \"envelope\":\n                return new Envelope\n            case \"lfo\":\n                return new LFO\n            default:\n                console.log(\"Error creating modulator\")\n                return null\n        }\n    }\n\n    createScale(target) {\n        switch (target) {\n            case \"vol\":\n                return new Tone.Scale(0, 1);\n            case \"mod\":\n                return new Tone.Scale(0, 1);\n            case \"pitch\":\n                return new Tone.Scale(0, 1);\n            case \"pan\":\n                return new Tone.Scale(0, 1);\n            default:\n                console.log(\"Error creating scale for target \"+target)\n                return null\n        }\n    }\n\n    updateModulators() {\n        this.allVoices.forEach(voice => {\n                for (let type in voice.modulators) {\n                    for (let target in voice.modulators[type]) {\n                        //update amount from preset\n                        voice.modulators[type][target].amount = this.modulatorsData[type][target].amount\n                        if (!toRaw(voice.modulators[type][target].signal)) {\n                            //IF IT'S STILL NOT CREATED\n                            //console.log(\"RECREATING\")\n                            voice.modulators[type][target].signal = this.createModulator(type)\n                            voice.modulators[type][target].scale = this.createScale(target)\n                            this.connectModulator(toRaw(voice.modulators[type][target]), type, target, toRaw(voice))\n                            //console.log(voice.modulators[type][target])\n                        }\n                        this.scaleSetter(voice.modulators[type][target], target)\n                        this.modulatorSetter(toRaw(voice.modulators[type][target].signal), type, this.modulatorsData[type][target].parameters)\n                    }\n                }\n            }\n        );\n    }\n\n    updateSynths() {\n        this.allVoices.forEach(voice => {\n            voice.synth.set({\n                \"detune\": this.synthPreset.transpose * 100,\n                \"oscillator\": {\n                    \"type\": this.synthPreset.type + this.synthPreset.waveform + this.synthPreset.partials\n                }\n            })\n            //this.gainNode.set({gain: Tone.dbToGain(this.synthPreset.vol)})\n            voice.noiseGain.set({\n                gain: this.synthPreset.mod\n            })\n        });\n    }\n\n    scaleSetter(modulator, target) {\n        switch (target) {\n            case \"vol\":\n                //ENVELOPE FOR VOL SHOULD HAVE SCALE TOO TO CENTER AROUND SELECTED FREQUENCY\n                toRaw(modulator.scale).set({\n                    min: (Math.max(Tone.dbToGain(this.synthPreset.vol) - modulator.amount,0)),\n                    max: (Math.min(Tone.dbToGain(this.synthPreset.vol) + modulator.amount,1)),\n                })\n\n\n                break;\n            case \"mod\":\n                toRaw(modulator.scale).set({\n                    min: (Math.max(this.synthPreset.mod - modulator.amount,0)),\n                    max: (Math.min(this.synthPreset.mod + modulator.amount,1)),\n                })\n                break;\n            case \"pitch\":\n                //TO-DO\n                //console.log(\"CHANGING SCALE \")\n                //console.log(modulator.scale)\n                toRaw(modulator.scale).set({\n                    min: ((this.synthPreset.transpose - 24 * modulator.amount) * 100),\n                    max: ((this.synthPreset.transpose + 24 * modulator.amount) * 100)\n                })\n                break;\n            case \"pan\":\n                //TO-DO\n                break;\n\n            default:\n                console.log(\"invalid target to connect modulator to\")\n                break;\n        }\n    }\n\n    modulatorSetter(modulator, type, parameters) {\n        // console.log(\"mypolysynth - modulator setter - parameters: \", toRaw(parameters).waveform)\n        if(!toRaw(parameters).waveform) toRaw(parameters).waveform = modulator.type\n\n        switch (type) {\n            case \"envelope\":\n                modulator.set({\n                    \"attack\": parameters.attack,\n                    \"decay\": parameters.decay,\n                    \"sustain\": parameters.sustain,\n                    \"release\": parameters.release + 0.001,\n                })\n                //console.log(\"JUST SET PARAMETERS OF\")\n                //console.log(modulator)\n                //console.log(\"WITH\")\n                //console.log(parameters)\n                break;\n            case \"lfo\":\n                //TO-DO\n                //console.log(\"PARAMETERS\")\n                //console.log(parameters)\n                modulator.set({//\n                    \"type\": toRaw(parameters).waveform,\n                    \"frequency\": toRaw(parameters).frequency\n                })\n                break;\n            default:\n                console.log(\"Error setting modulator parameters, invalid args\")\n                break;\n        }\n        // console.log(\"modulator.type: \", modulator.type)\n    }\n\n//have to pass, the modulator (tone), the type (lfo or envelope), the gain linked to the voice, the voice and the target\n    connectModulator(modulator, type, target, voice) {\n        //console.log(\"connecting\")\n        //console.log(modulator)\n        //console.log(\"to voice: \")\n        //console.log(voice)\n        //console.log(\"to target: \" + target)\n        switch (type) {\n            case \"envelope\":\n                switch (target) {\n                    case \"vol\":\n                        modulator.signal.chain(modulator.scale, voice.gain.gain)\n                        //modulator.signal.connect(voice.gain.gain)   //SET MAIN ADSR TO SYNTH GAIN\n                        modulator.signal.connect(voice.noiseAdsrGain.gain)      //SET MAIN ADSR TO NOISE GAIN\n                        break;\n                    case \"mod\":\n                        modulator.signal.chain(modulator.scale, voice.noiseGain.gain)\n                        break;\n                    case \"pitch\":\n                        //TO-DO\n                        this.scaleSetter(modulator, target)\n                        modulator.signal.chain(modulator.scale, voice.synth.detune)\n                        break;\n                    case \"pan\":\n                        //TO-DO\n                        break;\n                    default:\n                        console.log(\"invalid target to connect modulator to\")\n                        break;\n                }\n\n                break;\n\n            case \"lfo\":\n                switch (target) {\n                    case \"vol\":\n                        this.scaleSetter(modulator, target)\n                        modulator.signal.chain(modulator.scale, voice.lfoGain.gain)\n                        break;\n                    case \"mod\":\n                        modulator.signal.chain(modulator.scale, voice.noiseGain.gain)\n                        break;\n                    case \"pitch\":\n                        //TO-DO\n                        this.scaleSetter(modulator, target)\n                        modulator.signal.chain(modulator.scale, voice.synth.detune)\n                        break;\n                    case \"pan\":\n                        //TO-DO\n                        break;\n                    default:\n                        console.log(\"invalid target to connect modulator to\")\n                        break;\n                }\n\n                break;\n\n            default:\n                console.log(\"invalid modulator type\")\n                break;\n        }\n    }\n\n    // setters\n    setModulatorParameters(type, target, parameters) {\n        //console.log(\"myPolysynth - setModulatorParameters\")\n        if (this.initialized) {\n            this.modulatorsData[type][target].parameters = parameters\n            // console.log(\"New modulatorsData for type \"+type+\" to target \"+target)\n            // console.log(this.modulatorsData);\n            // console.log(\"params: \" , this.modulatorsData[type][target].parameters,  parameters)\n\n            this.updateModulators()\n            //console.log(\"SETTING\")\n            //console.log(this.modulatorsData)\n        }\n    }\n\n    setModulatorAmount(type, target, amount) {\n        if (this.initialized) {\n            this.modulatorsData[type][target].amount = amount\n            //console.log(\"setting modulator amount\")\n            this.updateModulators()\n        }\n    }\n\n    //TO RENAME IN SET SYNTH PARAMETERS\n    setParameters({\n                      volume = this.synthPreset.vol,\n                      modulation = this.synthPreset.mod,\n                      transpose = this.synthPreset.transpose,\n                      pan = this.synthPreset.pan,\n                      type = this.synthPreset.type,\n                      waveform = this.synthPreset.waveform\n                  }) {\n        if (this.initialized) {\n            this.synthPreset.vol = volume;\n            this.synthPreset.mod = modulation;\n            this.synthPreset.transpose = transpose;\n            this.synthPreset.pan = pan;\n            this.synthPreset.type = type;\n            this.synthPreset.waveform = waveform;\n            //console.log(this.synthPreset.waveform)\n\n            this.updateSynths()\n            this.updateModulators()\n        } else {\n            console.log(\"Polysynth not initialized\")\n        }\n    }\n\n// connect each voice to the new routing\n    connect(route) {\n        this.gainNode.connect(route)\n    }\n\n    disconnectDispose() {\n        //for each voice\n        this.allVoices.forEach(voice => {\n            //Disconnect and dispose synth\n            voice = toRaw(voice)\n            voice.synth.disconnect()\n            voice.synth.dispose()\n            //Disconnect and dispose gain\n            voice.gain.disconnect()\n            voice.gain.dispose()\n            //Disconnect and dispose modulators\n            for (let type in voice.modulators) {\n                for (let target in voice.modulators[type]) {\n                    if (voice.modulators[type][target].signal) {\n                        voice.modulators[type][target].signal.disconnect()\n                        voice.modulators[type][target].signal.dispose()\n                        voice.modulators[type][target].scale.disconnect()\n                        voice.modulators[type][target].scale.dispose()\n                    }\n                }\n            }\n        });\n        //disconnect and dispose main gainNode\n        this.gainNode.disconnect()\n        this.gainNode.dispose()\n\n        //console.log(\"MyPolySynth completely disconnected and disposed\")\n    }\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}