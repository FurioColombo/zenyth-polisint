{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Volume } from \"../component/channel/Volume\";\nimport \"../core/context/Destination\";\nimport \"../core/clock/Transport\";\nimport { ToneAudioNode } from \"../core/context/ToneAudioNode\";\nimport { defaultArg } from \"../core/util/Defaults\";\nimport { noOp, readOnly } from \"../core/util/Interface\";\nimport { StateTimeline } from \"../core/util/StateTimeline\";\nimport { isDefined, isUndef } from \"../core/util/TypeCheck\";\nimport { assert, assertContextRunning } from \"../core/util/Debug\";\nimport { GT } from \"../core/util/Math\";\n/**\n * Base class for sources.\n * start/stop of this.context.transport.\n *\n * ```\n * // Multiple state change events can be chained together,\n * // but must be set in the correct order and with ascending times\n * // OK\n * state.start().stop(\"+0.2\");\n * // OK\n * state.start().stop(\"+0.2\").start(\"+0.4\").stop(\"+0.7\")\n * // BAD\n * state.stop(\"+0.2\").start();\n * // BAD\n * state.start(\"+0.3\").stop(\"+0.2\");\n * ```\n */\nexport class Source extends ToneAudioNode {\n  constructor(options) {\n    super(options);\n    /**\n     * Sources have no inputs\n     */\n    this.input = undefined;\n    /**\n     * Keep track of the scheduled state.\n     */\n    this._state = new StateTimeline(\"stopped\");\n    /**\n     * The synced `start` callback function from the transport\n     */\n    this._synced = false;\n    /**\n     * Keep track of all of the scheduled event ids\n     */\n    this._scheduled = [];\n    /**\n     * Placeholder functions for syncing/unsyncing to transport\n     */\n    this._syncedStart = noOp;\n    this._syncedStop = noOp;\n    this._state.memory = 100;\n    this._state.increasing = true;\n    this._volume = this.output = new Volume({\n      context: this.context,\n      mute: options.mute,\n      volume: options.volume\n    });\n    this.volume = this._volume.volume;\n    readOnly(this, \"volume\");\n    this.onstop = options.onstop;\n  }\n  static getDefaults() {\n    return Object.assign(ToneAudioNode.getDefaults(), {\n      mute: false,\n      onstop: noOp,\n      volume: 0\n    });\n  }\n  /**\n   * Returns the playback state of the source, either \"started\" or \"stopped\".\n   * @example\n   * const player = new Tone.Player(\"https://tonejs.github.io/audio/berklee/ahntone_c3.mp3\", () => {\n   * \tplayer.start();\n   * \tconsole.log(player.state);\n   * }).toDestination();\n   */\n  get state() {\n    if (this._synced) {\n      if (this.context.transport.state === \"started\") {\n        return this._state.getValueAtTime(this.context.transport.seconds);\n      } else {\n        return \"stopped\";\n      }\n    } else {\n      return this._state.getValueAtTime(this.now());\n    }\n  }\n  /**\n   * Mute the output.\n   * @example\n   * const osc = new Tone.Oscillator().toDestination().start();\n   * // mute the output\n   * osc.mute = true;\n   */\n  get mute() {\n    return this._volume.mute;\n  }\n  set mute(mute) {\n    this._volume.mute = mute;\n  }\n  /**\n   * Ensure that the scheduled time is not before the current time.\n   * Should only be used when scheduled unsynced.\n   */\n  _clampToCurrentTime(time) {\n    if (this._synced) {\n      return time;\n    } else {\n      return Math.max(time, this.context.currentTime);\n    }\n  }\n  /**\n   * Start the source at the specified time. If no time is given,\n   * start the source now.\n   * @param  time When the source should be started.\n   * @example\n   * const source = new Tone.Oscillator().toDestination();\n   * source.start(\"+0.5\"); // starts the source 0.5 seconds from now\n   */\n  start(time, offset, duration) {\n    let computedTime = isUndef(time) && this._synced ? this.context.transport.seconds : this.toSeconds(time);\n    computedTime = this._clampToCurrentTime(computedTime);\n    // if it's started, stop it and restart it\n    if (!this._synced && this._state.getValueAtTime(computedTime) === \"started\") {\n      // time should be strictly greater than the previous start time\n      assert(GT(computedTime, this._state.get(computedTime).time), \"Start time must be strictly greater than previous start time\");\n      this._state.cancel(computedTime);\n      this._state.setStateAtTime(\"started\", computedTime);\n      this.log(\"restart\", computedTime);\n      this.restart(computedTime, offset, duration);\n    } else {\n      this.log(\"start\", computedTime);\n      this._state.setStateAtTime(\"started\", computedTime);\n      if (this._synced) {\n        // add the offset time to the event\n        const event = this._state.get(computedTime);\n        if (event) {\n          event.offset = this.toSeconds(defaultArg(offset, 0));\n          event.duration = duration ? this.toSeconds(duration) : undefined;\n        }\n        const sched = this.context.transport.schedule(t => {\n          this._start(t, offset, duration);\n        }, computedTime);\n        this._scheduled.push(sched);\n        // if the transport is already started\n        // and the time is greater than where the transport is\n        if (this.context.transport.state === \"started\" && this.context.transport.getSecondsAtTime(this.immediate()) > computedTime) {\n          this._syncedStart(this.now(), this.context.transport.seconds);\n        }\n      } else {\n        assertContextRunning(this.context);\n        this._start(computedTime, offset, duration);\n      }\n    }\n    return this;\n  }\n  /**\n   * Stop the source at the specified time. If no time is given,\n   * stop the source now.\n   * @param  time When the source should be stopped.\n   * @example\n   * const source = new Tone.Oscillator().toDestination();\n   * source.start();\n   * source.stop(\"+0.5\"); // stops the source 0.5 seconds from now\n   */\n  stop(time) {\n    let computedTime = isUndef(time) && this._synced ? this.context.transport.seconds : this.toSeconds(time);\n    computedTime = this._clampToCurrentTime(computedTime);\n    if (this._state.getValueAtTime(computedTime) === \"started\" || isDefined(this._state.getNextState(\"started\", computedTime))) {\n      this.log(\"stop\", computedTime);\n      if (!this._synced) {\n        this._stop(computedTime);\n      } else {\n        const sched = this.context.transport.schedule(this._stop.bind(this), computedTime);\n        this._scheduled.push(sched);\n      }\n      this._state.cancel(computedTime);\n      this._state.setStateAtTime(\"stopped\", computedTime);\n    }\n    return this;\n  }\n  /**\n   * Restart the source.\n   */\n  restart(time, offset, duration) {\n    time = this.toSeconds(time);\n    if (this._state.getValueAtTime(time) === \"started\") {\n      this._state.cancel(time);\n      this._restart(time, offset, duration);\n    }\n    return this;\n  }\n  /**\n   * Sync the source to the Transport so that all subsequent\n   * calls to `start` and `stop` are synced to the TransportTime\n   * instead of the AudioContext time.\n   *\n   * @example\n   * const osc = new Tone.Oscillator().toDestination();\n   * // sync the source so that it plays between 0 and 0.3 on the Transport's timeline\n   * osc.sync().start(0).stop(0.3);\n   * // start the transport.\n   * Tone.Transport.start();\n   * // set it to loop once a second\n   * Tone.Transport.loop = true;\n   * Tone.Transport.loopEnd = 1;\n   */\n  sync() {\n    if (!this._synced) {\n      this._synced = true;\n      this._syncedStart = (time, offset) => {\n        if (offset > 0) {\n          // get the playback state at that time\n          const stateEvent = this._state.get(offset);\n          // listen for start events which may occur in the middle of the sync'ed time\n          if (stateEvent && stateEvent.state === \"started\" && stateEvent.time !== offset) {\n            // get the offset\n            const startOffset = offset - this.toSeconds(stateEvent.time);\n            let duration;\n            if (stateEvent.duration) {\n              duration = this.toSeconds(stateEvent.duration) - startOffset;\n            }\n            this._start(time, this.toSeconds(stateEvent.offset) + startOffset, duration);\n          }\n        }\n      };\n      this._syncedStop = time => {\n        const seconds = this.context.transport.getSecondsAtTime(Math.max(time - this.sampleTime, 0));\n        if (this._state.getValueAtTime(seconds) === \"started\") {\n          this._stop(time);\n        }\n      };\n      this.context.transport.on(\"start\", this._syncedStart);\n      this.context.transport.on(\"loopStart\", this._syncedStart);\n      this.context.transport.on(\"stop\", this._syncedStop);\n      this.context.transport.on(\"pause\", this._syncedStop);\n      this.context.transport.on(\"loopEnd\", this._syncedStop);\n    }\n    return this;\n  }\n  /**\n   * Unsync the source to the Transport. See Source.sync\n   */\n  unsync() {\n    if (this._synced) {\n      this.context.transport.off(\"stop\", this._syncedStop);\n      this.context.transport.off(\"pause\", this._syncedStop);\n      this.context.transport.off(\"loopEnd\", this._syncedStop);\n      this.context.transport.off(\"start\", this._syncedStart);\n      this.context.transport.off(\"loopStart\", this._syncedStart);\n    }\n    this._synced = false;\n    // clear all of the scheduled ids\n    this._scheduled.forEach(id => this.context.transport.clear(id));\n    this._scheduled = [];\n    this._state.cancel(0);\n    // stop it also\n    this._stop(0);\n    return this;\n  }\n  /**\n   * Clean up.\n   */\n  dispose() {\n    super.dispose();\n    this.onstop = noOp;\n    this.unsync();\n    this._volume.dispose();\n    this._state.dispose();\n    return this;\n  }\n}","map":{"version":3,"mappings":"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","names":["Volume","ToneAudioNode","defaultArg","noOp","readOnly","StateTimeline","isDefined","isUndef","assert","assertContextRunning","GT","Source","constructor","options","undefined","_state","memory","increasing","_volume","output","context","mute","volume","onstop","getDefaults","Object","assign","state","_synced","transport","getValueAtTime","seconds","now","_clampToCurrentTime","time","Math","max","currentTime","start","offset","duration","computedTime","toSeconds","get","cancel","setStateAtTime","log","restart","event","sched","schedule","t","_start","_scheduled","push","getSecondsAtTime","immediate","_syncedStart","stop","getNextState","_stop","bind","_restart","sync","stateEvent","startOffset","_syncedStop","sampleTime","on","unsync","off","forEach","id","clear","dispose"],"sourceRoot":"","sources":["../../../Tone/source/Source.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module","externalDependencies":[]}