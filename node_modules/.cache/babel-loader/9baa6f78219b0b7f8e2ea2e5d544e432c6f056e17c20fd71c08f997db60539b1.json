{"ast":null,"code":"import { normalizeStyle as _normalizeStyle, createElementVNode as _createElementVNode, openBlock as _openBlock, createElementBlock as _createElementBlock } from \"vue\";\nconst _hoisted_1 = {\n  class: \"lfoOscilloscope\"\n};\nexport function render(_ctx, _cache, $props, $setup, $data, $options) {\n  return _openBlock(), _createElementBlock(\"div\", _hoisted_1, [_createElementVNode(\"canvas\", {\n    ref: \"canvas\",\n    class: \"lfoOscilloscopeCanvas\",\n    style: _normalizeStyle(this.oscilloscopeCanvas)\n  }, null, 4 /* STYLE */)]);\n}","map":{"version":3,"mappings":";;EACOA,KAAK,EAAC;AAAiB;;uBAA5BC,oBAEM,OAFNC,UAEM,GADJC,oBAA6F;IAArFC,GAAG,EAAC,QAAQ;IAACJ,KAAK,EAAC,uBAAuB;IAAEK,KAAK,uBAAOC,kBAAkB","names":["class","_createElementBlock","_hoisted_1","_createElementVNode","ref","style","oscilloscopeCanvas"],"sourceRoot":"","sources":["/Users/guglielmofratticioli/Documents/POLIMI/FurioColombo.github.io/src/views/Synth/Modulators/LfoVisualizer.vue"],"sourcesContent":["<template>\n  <div class=\"lfoOscilloscope\">\n    <canvas ref=\"canvas\" class=\"lfoOscilloscopeCanvas\" :style=\"this.oscilloscopeCanvas\"></canvas>\n  </div>\n</template>\n\n<script>\nimport {nextTick} from \"vue\";\n\nconst qualFactor = 50\nconst sinValsBuffer = new Array(qualFactor).fill(0);\nconst triValsBuffer = new Array(qualFactor).fill(0);\nconst sqValsBuffer = new Array(qualFactor).fill(0);\nconst sawValsBuffer = new Array(qualFactor).fill(0);\n\n//todo: rmv real audio\n// todo: remap dept in -0.5 + 0.5 range\n// todo: start only when needs to be visualized\n\nexport default {\n  components: {},\n  props: [\"freq\", \"depth\", \"wave\"],\n  data() {\n    return {\n      timing: 10,\n      //freq: this.freq,\n      //depth: this.depth,\n      intervalId: \"\",\n      waveform: this.wave\n    }\n  },\n\n  mounted() {\n    //console.log(\"mounted LfoVisual\")\n    this.timing = 1000 / (qualFactor * this.$props.freq);\n    for (let i = 0; i < qualFactor; i++) {\n      sinValsBuffer[i] = Math.sin(Math.PI*2/qualFactor * i) * this.$props.depth;\n      triValsBuffer[i] = this.$props.depth - 2*Math.abs(2*(i - qualFactor/2)/qualFactor) * this.$props.depth\n      i >= qualFactor/2? sqValsBuffer[i] = this.$props.depth : sqValsBuffer[i] = - this.$props.depth\n      sawValsBuffer[i] = this.depth * (2*i/qualFactor -1)\n    }\n\n    switch (this.waveform) {\n      case 'sine':\n        this.oscilloscopeData = sinValsBuffer\n        break;\n      case 'triangle':\n        this.oscilloscopeData = triValsBuffer\n        break;\n      case 'square':\n        this.oscilloscopeData = sqValsBuffer;\n        break;\n      case 'sawtooth':\n        this.oscilloscopeData = sawValsBuffer;\n        break;\n      default:\n        console.log(\"ERROR - waveform not recognised\")\n    }\n\n    // --------- GRAPHICS INIT --------\n    // use the ref to get the canvas element\n    this.canvas = this.$refs.canvas;\n\n    // set the canvas width and height to 100%\n    this.canvas.width = 4*this.canvas.offsetWidth;\n    this.canvas.height = 4*this.canvas.offsetHeight;\n    // get the canvas context\n    this.ctx = this.canvas.getContext(\"2d\");\n  },\n\n  methods: {\n    updateParams({ freq = this.$props.freq, depth = this.$props.depth, waveform = this.waveform }) {\n      //this.$props.freq = freq;\n      //this.$props.depth = depth;\n      this.waveform = waveform;\n      //console.log(\"this.wave: \" + waveform);\n\n      this.timing = 1000 / (qualFactor * this.$props.freq);\n      switch (this.waveform) {\n        case 'sine':\n          this.oscilloscopeData = sinValsBuffer\n          break;\n        case 'triangle':\n          this.oscilloscopeData = triValsBuffer\n          break;\n        case 'square':\n          this.oscilloscopeData = sqValsBuffer;\n          break;\n        case 'sawtooth':\n          this.oscilloscopeData = sawValsBuffer;\n          break;\n        default:\n          console.log(\"ERROR - waveform not recognised\")\n      }\n\n      if(this.intervalId){ clearInterval(this.intervalId) }\n      this.stopOscilloscope();\n      console.log(\"end - this.wave: \" + waveform)\n\n      nextTick(() => {\n        this.startOscilloscope()\n      })\n    },\n\n    startOscilloscope() {\n      this.canvas.width = 4*this.canvas.offsetWidth;\n      this.canvas.height = 4*this.canvas.offsetHeight;\n      console.log(\"start - this.waveform: \" + this.waveform)\n\n     // console.log(\"this.timing: \" + this.timing)\n     // console.log(\"avviando oscilloscope con timer \" + this.timing)\n      this.intervalId = setInterval(() => {\n        let t = this.oscilloscopeData.shift();\n        this.oscilloscopeData.push(t);\n        this.draw(this.oscilloscopeData);\n      }, this.timing);\n      //console.log(\"this.timing:  \" + this.intervalId);\n    },\n\n    stopOscilloscope(){\n      if(this.intervalId){ clearInterval(this.intervalId) }\n    },\n\n    draw(data) {\n      // clear the canvas\n      //console.log(\"drawing\")\n      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n      let x, y, y_next;\n\n      // draw the data on the canvas\n      // set the line color\n      this.ctx.strokeStyle = \"black\";\n      // set the line width\n      this.ctx.lineWidth = 2;\n      this.ctx.beginPath();\n\n      y_next = (this.canvas.height / 2) * (1 - data[0]).toFixed(3);\n      // loop through the data and plot it on the canvas\n      for (let i = 1; i < data.length; i++) {\n        y = y_next;\n        // calculate the x and y position of the point\n        x = i * (this.canvas.width / data.length).toFixed(3);\n        y_next = (this.canvas.height / 2) * (1 - data[i]).toFixed(3);\n        // move to the x and y position\n        this.ctx.moveTo(x, y);\n        // draw a line to the next point\n        this.ctx.lineTo(x + this.canvas.width / data.length, y_next );\n        // console.log(x, y)\n      }\n      // draw the line\n      this.ctx.stroke();\n      this.ctx.moveTo(0, 0);\n    },\n\n    beforeDestroy() {\n      if (this.oscilloscope) {\n        this.oscilloscope.disconnect();\n        this.oscilloscope.dispose();\n      }\n    },\n  }, \n  computed: {\n    oscilloscopeCanvas(){\n      return {\n        background: this.colors.purple.glow\n      } \n    }\n  }\n}\n</script>\n\n<style>\n.lfoOscilloscope {\n  margin: 0.4vw;\n  margin-right: 0.1vw;;\n  height: 90%;\n  width: 90%;\n  border: 0;\n  padding: 0;\n  box-sizing: border-box;\n  position: relative;\n}\n\n.lfoOscilloscopeCanvas {\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n  border-radius: 0.2vw;\n  border: 0.06vw solid #334030;\n  box-sizing: border-box;\n  margin: 0;\n  padding: 0;\n}\n</style>"]},"metadata":{},"sourceType":"module","externalDependencies":[]}