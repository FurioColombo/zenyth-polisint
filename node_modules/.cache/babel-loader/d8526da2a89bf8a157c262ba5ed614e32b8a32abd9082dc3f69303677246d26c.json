{"ast":null,"code":"import { ToneWithContext } from \"../context/ToneWithContext\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Emitter } from \"../util/Emitter\";\nimport { noOp, readOnly } from \"../util/Interface\";\nimport { StateTimeline } from \"../util/StateTimeline\";\nimport { TickSource } from \"./TickSource\";\nimport { assertContextRunning } from \"../util/Debug\";\n/**\n * A sample accurate clock which provides a callback at the given rate.\n * While the callback is not sample-accurate (it is still susceptible to\n * loose JS timing), the time passed in as the argument to the callback\n * is precise. For most applications, it is better to use Tone.Transport\n * instead of the Clock by itself since you can synchronize multiple callbacks.\n * @example\n * // the callback will be invoked approximately once a second\n * // and will print the time exactly once a second apart.\n * const clock = new Tone.Clock(time => {\n * \tconsole.log(time);\n * }, 1);\n * clock.start();\n * @category Core\n */\nexport class Clock extends ToneWithContext {\n  constructor() {\n    super(optionsFromArguments(Clock.getDefaults(), arguments, [\"callback\", \"frequency\"]));\n    this.name = \"Clock\";\n    /**\n     * The callback function to invoke at the scheduled tick.\n     */\n    this.callback = noOp;\n    /**\n     * The last time the loop callback was invoked\n     */\n    this._lastUpdate = 0;\n    /**\n     * Keep track of the playback state\n     */\n    this._state = new StateTimeline(\"stopped\");\n    /**\n     * Context bound reference to the _loop method\n     * This is necessary to remove the event in the end.\n     */\n    this._boundLoop = this._loop.bind(this);\n    const options = optionsFromArguments(Clock.getDefaults(), arguments, [\"callback\", \"frequency\"]);\n    this.callback = options.callback;\n    this._tickSource = new TickSource({\n      context: this.context,\n      frequency: options.frequency,\n      units: options.units\n    });\n    this._lastUpdate = 0;\n    this.frequency = this._tickSource.frequency;\n    readOnly(this, \"frequency\");\n    // add an initial state\n    this._state.setStateAtTime(\"stopped\", 0);\n    // bind a callback to the worker thread\n    this.context.on(\"tick\", this._boundLoop);\n  }\n  static getDefaults() {\n    return Object.assign(ToneWithContext.getDefaults(), {\n      callback: noOp,\n      frequency: 1,\n      units: \"hertz\"\n    });\n  }\n  /**\n   * Returns the playback state of the source, either \"started\", \"stopped\" or \"paused\".\n   */\n  get state() {\n    return this._state.getValueAtTime(this.now());\n  }\n  /**\n   * Start the clock at the given time. Optionally pass in an offset\n   * of where to start the tick counter from.\n   * @param  time    The time the clock should start\n   * @param offset  Where the tick counter starts counting from.\n   */\n  start(time, offset) {\n    // make sure the context is running\n    assertContextRunning(this.context);\n    // start the loop\n    const computedTime = this.toSeconds(time);\n    this.log(\"start\", computedTime);\n    if (this._state.getValueAtTime(computedTime) !== \"started\") {\n      this._state.setStateAtTime(\"started\", computedTime);\n      this._tickSource.start(computedTime, offset);\n      if (computedTime < this._lastUpdate) {\n        this.emit(\"start\", computedTime, offset);\n      }\n    }\n    return this;\n  }\n  /**\n   * Stop the clock. Stopping the clock resets the tick counter to 0.\n   * @param time The time when the clock should stop.\n   * @example\n   * const clock = new Tone.Clock(time => {\n   * \tconsole.log(time);\n   * }, 1);\n   * clock.start();\n   * // stop the clock after 10 seconds\n   * clock.stop(\"+10\");\n   */\n  stop(time) {\n    const computedTime = this.toSeconds(time);\n    this.log(\"stop\", computedTime);\n    this._state.cancel(computedTime);\n    this._state.setStateAtTime(\"stopped\", computedTime);\n    this._tickSource.stop(computedTime);\n    if (computedTime < this._lastUpdate) {\n      this.emit(\"stop\", computedTime);\n    }\n    return this;\n  }\n  /**\n   * Pause the clock. Pausing does not reset the tick counter.\n   * @param time The time when the clock should stop.\n   */\n  pause(time) {\n    const computedTime = this.toSeconds(time);\n    if (this._state.getValueAtTime(computedTime) === \"started\") {\n      this._state.setStateAtTime(\"paused\", computedTime);\n      this._tickSource.pause(computedTime);\n      if (computedTime < this._lastUpdate) {\n        this.emit(\"pause\", computedTime);\n      }\n    }\n    return this;\n  }\n  /**\n   * The number of times the callback was invoked. Starts counting at 0\n   * and increments after the callback was invoked.\n   */\n  get ticks() {\n    return Math.ceil(this.getTicksAtTime(this.now()));\n  }\n  set ticks(t) {\n    this._tickSource.ticks = t;\n  }\n  /**\n   * The time since ticks=0 that the Clock has been running. Accounts for tempo curves\n   */\n  get seconds() {\n    return this._tickSource.seconds;\n  }\n  set seconds(s) {\n    this._tickSource.seconds = s;\n  }\n  /**\n   * Return the elapsed seconds at the given time.\n   * @param  time  When to get the elapsed seconds\n   * @return  The number of elapsed seconds\n   */\n  getSecondsAtTime(time) {\n    return this._tickSource.getSecondsAtTime(time);\n  }\n  /**\n   * Set the clock's ticks at the given time.\n   * @param  ticks The tick value to set\n   * @param  time  When to set the tick value\n   */\n  setTicksAtTime(ticks, time) {\n    this._tickSource.setTicksAtTime(ticks, time);\n    return this;\n  }\n  /**\n   * Get the time of the given tick. The second argument\n   * is when to test before. Since ticks can be set (with setTicksAtTime)\n   * there may be multiple times for a given tick value.\n   * @param  tick The tick number.\n   * @param  before When to measure the tick value from.\n   * @return The time of the tick\n   */\n  getTimeOfTick(tick, before = this.now()) {\n    return this._tickSource.getTimeOfTick(tick, before);\n  }\n  /**\n   * Get the clock's ticks at the given time.\n   * @param  time  When to get the tick value\n   * @return The tick value at the given time.\n   */\n  getTicksAtTime(time) {\n    return this._tickSource.getTicksAtTime(time);\n  }\n  /**\n   * Get the time of the next tick\n   * @param  offset The tick number.\n   */\n  nextTickTime(offset, when) {\n    const computedTime = this.toSeconds(when);\n    const currentTick = this.getTicksAtTime(computedTime);\n    return this._tickSource.getTimeOfTick(currentTick + offset, computedTime);\n  }\n  /**\n   * The scheduling loop.\n   */\n  _loop() {\n    const startTime = this._lastUpdate;\n    const endTime = this.now();\n    this._lastUpdate = endTime;\n    this.log(\"loop\", startTime, endTime);\n    if (startTime !== endTime) {\n      // the state change events\n      this._state.forEachBetween(startTime, endTime, e => {\n        switch (e.state) {\n          case \"started\":\n            const offset = this._tickSource.getTicksAtTime(e.time);\n            this.emit(\"start\", e.time, offset);\n            break;\n          case \"stopped\":\n            if (e.time !== 0) {\n              this.emit(\"stop\", e.time);\n            }\n            break;\n          case \"paused\":\n            this.emit(\"pause\", e.time);\n            break;\n        }\n      });\n      // the tick callbacks\n      this._tickSource.forEachTickBetween(startTime, endTime, (time, ticks) => {\n        this.callback(time, ticks);\n      });\n    }\n  }\n  /**\n   * Returns the scheduled state at the given time.\n   * @param  time  The time to query.\n   * @return  The name of the state input in setStateAtTime.\n   * @example\n   * const clock = new Tone.Clock();\n   * clock.start(\"+0.1\");\n   * clock.getStateAtTime(\"+0.1\"); // returns \"started\"\n   */\n  getStateAtTime(time) {\n    const computedTime = this.toSeconds(time);\n    return this._state.getValueAtTime(computedTime);\n  }\n  /**\n   * Clean up\n   */\n  dispose() {\n    super.dispose();\n    this.context.off(\"tick\", this._boundLoop);\n    this._tickSource.dispose();\n    this._state.dispose();\n    return this;\n  }\n}\nEmitter.mixin(Clock);","map":{"version":3,"mappings":"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","names":["ToneWithContext","optionsFromArguments","Emitter","noOp","readOnly","StateTimeline","TickSource","assertContextRunning","Clock","constructor","getDefaults","arguments","_loop","bind","options","callback","_tickSource","context","frequency","units","_lastUpdate","_state","setStateAtTime","on","_boundLoop","Object","assign","state","getValueAtTime","now","start","time","offset","computedTime","toSeconds","log","emit","stop","cancel","pause","ticks","Math","ceil","getTicksAtTime","t","seconds","s","getSecondsAtTime","setTicksAtTime","getTimeOfTick","tick","before","nextTickTime","when","currentTick","startTime","endTime","forEachBetween","e","forEachTickBetween","getStateAtTime","dispose","off","mixin"],"sourceRoot":"","sources":["../../../../Tone/core/clock/Clock.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module","externalDependencies":[]}